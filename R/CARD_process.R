# Copyright 2021-2023 Louis Héraut (louis.heraut@inrae.fr)*1,
#                     Éric Sauquet (eric.sauquet@inrae.fr)*1,
#           2023 Jean-Philippe Vidal (jean-philippe.vidal@inrae.fr)*1,
#                Nathan Pellerin (nathan.pellerin@inrae.fr)*1
#
# *1   INRAE, France
#
# This file is part of EXstat R package.
#
# EXstat R package is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# EXstat R package is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with EXstat R package.
# If not, see <https://www.gnu.org/licenses/>.




reduce_process = function (data, id, Process,
                           period=NULL,
                           suffix=NULL,
                           cancel_lim=FALSE,
                           expand_overwrite=NULL,
                           samplePeriod_overwrite=NULL,
                           verbose=FALSE) {

    if (verbose) {
        print(paste0("Process ", id, "/", length(Process)))
    }
    
    process = Process[[paste0("P", id)]]
    process_names = names(process)
    for (pp in 1:length(process)) {
        assign(process_names[pp], process[[pp]])
    }

    rm ("process")
    gc()
    
    if (!is.null(expand_overwrite)) {
        expand = expand_overwrite
    }
    
    if (is.null(samplePeriod_overwrite)) {
        if (is.function(samplePeriod[[1]])) {
            samplePeriod = dplyr::tibble(sp=list(samplePeriod[[1]]),
                                         args=samplePeriod[2])
        }
    } else {
        samplePeriod = samplePeriod_overwrite
    }

    if (cancel_lim) {
        NApct_lim = NULL
        NAyear_lim = NULL
    }

    # EXtraction
    data = process_extraction(data=data,
                              funct=funct,
                              funct_args=funct_args,
                              timeStep=timeStep,
                              samplePeriod=samplePeriod,
                              period=period,
                              isDate=isDate,
                              NApct_lim=NApct_lim,
                              NAyear_lim=NAyear_lim,
                              Seasons=Seasons,
                              onlyDate4Season=onlyDate4Season,
                              nameEX=nameEX,
                              suffix=suffix,
                              keep=keep,
                              compress=compress,
                              expand=expand,
                              rmNApct=rmNApct,
                              verbose=verbose)
    return (data)
}




get_last_Process = function (Process) {
    nProcess = length(Process) - 1
    for (i in 1:nProcess) {
        process = Process[[paste0("P", i)]]
        process_names = names(process)
        for (pp in 1:length(process)) {
            assign(process_names[pp], process[[pp]])
        }
    }
    res = list(compress=compress, timeStep=timeStep, Seasons=Seasons)
    return (res)
}


#' @title CARD_extraction
#' @description The function extract specified data from a set of script files.
#' @param data Tibble used in the extraction
#' @param CARD_path directory path where CARD_dir is located
#' @param CARD_dir default="WIP", specify the name of the subdirectory in which to find the script files.
#' @param CARD_name specify the name of the script files to be used
#' @param period specify a period to extract from data
#' @param simplify specify whether or not to simplify the extracted data by a column name
#' @param verbose default=FALSE, if set to TRUE, the function will print out the process details
#' @return a list of extracted data, along with meta data.
#' @note documentation generated by chatGPT
#' @export
CARD_extraction = function (data, CARD_path, CARD_dir="WIP",
                            CARD_name=NULL, CARD_tmp=NULL,
                            period=NULL,
                            suffix=NULL, 
                            cancel_lim=FALSE, simplify=NULL,
                            expand_overwrite=NULL,
                            samplePeriod_overwrite=NULL,
                            verbose=FALSE) {


    
    if (is.null(CARD_tmp)) {
        CARD_tmp = CARD_path
    }
    
    CARD_dirpath = file.path(CARD_tmp, CARD_dir)   
    script_to_analyse = list.files(CARD_dirpath,
                                   pattern=".R$",
                                   recursive=TRUE,
                                   include.dirs=FALSE,
                                   full.names=FALSE)

    if (!is.null(CARD_name)) {
        script_to_analyse = script_to_analyse[script_to_analyse %in%
                                              CARD_name]
    }
    
    script_to_analyse = script_to_analyse[!grepl("__default__.R",
                                                 script_to_analyse)]

    topic_to_analyse = list.dirs(CARD_dirpath,
                                 recursive=TRUE, full.names=FALSE)
    topic_to_analyse = topic_to_analyse[topic_to_analyse != ""]
    topic_to_analyse = gsub('.*_', '', topic_to_analyse)

    structure = replicate(length(topic_to_analyse), c())
    names(structure) = topic_to_analyse

    var_analyse = c()

    nScript = length(script_to_analyse)
    metaEX = dplyr::tibble()
    dataEX = replicate(nScript, list(NULL))

    for (ss in 1:nScript) {

        script = script_to_analyse[ss]

        list_path = list.files(file.path(CARD_path,
                                         "__tools__"),
                               pattern='*.R$',
                               recursive=TRUE,
                               full.names=TRUE)
        for (path in list_path) {
            source(path, encoding='UTF-8')    
        }

        Process_default = sourceProcess(
            file.path(CARD_path, "__default__.R"))
        
        Process = sourceProcess(
            file.path(CARD_dirpath, script),
            default=Process_default)

        principal = Process$P
        principal_names = names(principal)
        for (pp in 1:length(principal)) {
            assign(principal_names[pp], principal[[pp]])
        }
        
        split_script = split_path(script)
        
        if (length(split_script) == 1) {
            if (!('None' %in% names(structure))) {
                structure = append(list(None=c()), structure)
            }
            structure[['None']] = c(structure[['None']], var)
        } else if (length(split_script) == 2) {
            dir = split_script[2]
            dir = gsub('.*_', '', dir)
            structure[[dir]] = c(structure[[dir]], var)
        }

        if (any(var %in% var_analyse)) {
            next
        }
        
        var_analyse = c(var_analyse, var)

        if (verbose) {
            print(paste0('Computes ', Process$P$var))
        }

        # nProcess = length(Process) - 1
        # dataEX_tmp = data

        # for (i in 1:nProcess) {

        #     if (verbose) {
        #         print(paste0("Process ", i, "/", nProcess))
        #     }
            
        #     process = Process[[paste0("P", i)]]
        #     process_names = names(process)
        #     for (pp in 1:length(process)) {
        #         assign(process_names[pp], process[[pp]])
        #     }

        #     rm ("process")
        #     gc()
            
        #     if (!is.null(expand_overwrite)) {
        #         expand = expand_overwrite
        #     }
            
        #     if (is.null(samplePeriod_overwrite)) {
        #         if (is.function(samplePeriod[[1]])) {
        #             samplePeriod = dplyr::tibble(sp=list(samplePeriod[[1]]),
        #                                          args=samplePeriod[2])
        #         }
        #     } else {
        #         samplePeriod = samplePeriod_overwrite
        #     }

        #     if (cancel_lim) {
        #         NApct_lim = NULL
        #         NAyear_lim = NULL
        #     }

        #     # EXtraction
        #     dataEX_tmp = do.call(
        #         what=process_extraction,
        #         args=list(data=dataEX_tmp,
        #                   funct=funct,
        #                   funct_args=funct_args,
        #                   timeStep=timeStep,
        #                   samplePeriod=samplePeriod,
        #                   period=period,
        #                   isDate=isDate,
        #                   NApct_lim=NApct_lim,
        #                   NAyear_lim=NAyear_lim,
        #                   Seasons=Seasons,
        #                   onlyDate4Season=onlyDate4Season,
        #                   nameEX=nameEX,
        #                   suffix=suffix,
        #                   keep=keep,
        #                   compress=compress,
        #                   expand=expand,
        #                   rmNApct=rmNApct,
        #                   verbose=verbose))
        # }

        ###################
        # if (verbose) {
        #     print(paste0("Data extracted for ", var))
        #     print(dataEX_tmp)
        # }

        # if (tibble::is_tibble(dataEX_tmp)) {
        #     if (length(suffix) == 1) {
        #         var = paste0(var, suffix)
        #     }
        #     dataEX_tmp = list(dataEX_tmp)
        #     var = paste0(var, collapse=" ")
        #     glose = paste0(glose, collapse=" ")
        #     names(dataEX_tmp) = var
        # }
        ####################
        
        # dataEX = append(dataEX, dataEX_tmp)

        var_meta = var

        nProcess = length(Process) - 1
        
        dataEX[[ss]] =
            purrr::reduce(1:nProcess,
                          reduce_process,
                          Process=Process,
                          period=period,
                          suffix=suffix,
                          cancel_lim=cancel_lim,
                          expand_overwrite=expand_overwrite,
                          samplePeriod_overwrite=samplePeriod_overwrite,
                          verbose=verbose,
                          .init=data)
        
        
        if (tibble::is_tibble(dataEX[[ss]])) {
            if (length(suffix) == 1) {
                var = paste0(var, suffix)
            }
            dataEX[[ss]] = list(dataEX[[ss]])
            if (!simplify) {
                var = paste0(var, collapse=" ")
                glose = paste0(glose, collapse=" ")
                names(dataEX[[ss]]) = var
            }
        }

        res = get_last_Process(Process)
        rm ("Process")
        gc()

        compress = res$compress
        timeStep = res$timeStep
        Seasons = res$Seasons

        metaEX = dplyr::bind_rows(
                            metaEX,
                            dplyr::tibble(var=var_meta,
                                          unit=unit,
                                          glose=glose,
                                          topic=
                                              paste0(topic,
                                                     collapse="/"),
                                          samplePeriod=
                                              paste0(samplePeriod,
                                                     collapse="/")))
    }

    rm ("data")
    gc()

    dataEX = unlist(dataEX, recursive=FALSE)
    if (!simplify) {
        dataEX = dataEX[match(names(dataEX), table=metaEX$var)]
    }
    
    if (simplify) {
        by = names(dplyr::select(dataEX[[1]],
                                 dplyr::where(is.character)))
        dataEX = purrr::reduce(.x=dataEX, .f=full_join, by=by)
    }

    return (list(metaEX=metaEX, dataEX=dataEX))
}


#' @title CARD_trend
#' @description The function applies trend analysis on the extracted data. It uses the CARD_extraction function to extract data first.
#' @param data Tibble used in the extraction
#' @param CARD_path directory path where CARD_dir is located
#' @param CARD_dir default="WIP", specify the name of the subdirectory in which to find the script files.
#' @param CARD_name specify the name of the script files to be used
#' @param simplify specify whether or not to simplify the extracted data
#' @param level default=0.1, level for the trend analysis
#' @param period specify a period to extract from data
#' @param samplePeriod_by_topic specify a sample period per topic
#' @param verbose default=TRUE, if set to TRUE, the function will print out the process details
#' @return a list of extracted data, meta data, and trend data.
#' @note documentation generated by chatGPT
#' @export
CARD_trend = function (data, CARD_path, CARD_dir="WIP", CARD_name=NULL,
                       CARD_tmp=NULL, period=NULL, variable_names=NULL,
                       cancel_lim=FALSE, simplify=NULL, level=0.1,
                       samplePeriod_overwrite=NULL,
                       verbose=FALSE) {

    if (verbose) {
        print(paste0('Computes ', 'trend'))
    }

    res = CARD_extraction(data,
                          CARD_path=CARD_path,
                          CARD_dir=CARD_dir,
                          CARD_name=CARD_name,
                          CARD_tmp=CARD_tmp,
                          period=period,
                          variable_names=variable_names,
                          cancel_lim=cancel_lim,
                          simplify=simplify,
                          samplePeriod_overwrite=samplePeriod_overwrite,
                          verbose=verbose)

    
    if (simplify) {
        # Compute the trend analysis
        trendEX = process_trend(data=res$dataEX,
                                MK_level=level,
                                timeDep_option="AR1",
                                verbose=verbose)
    } else {
        trendEX = list()
        for (i in 1:length(res$dataEX)) {
            trendEX = append(trendEX,
                             list(process_trend(data=res$dataEX[[i]],
                                                MK_level=level,
                                                timeDep_option="AR1",
                                                verbose=verbose)))
            names(trendEX)[length(trendEX)] = names(res$dataEX)[i]
        }
    }
    
    # Creates a list of results to return
    res = list(metaEX=res$metaEX,
               dataEX=res$dataEX,
               trendEX=trendEX)
    
    return (res)
}


#' @title sourceProcess
#' @description The function reads an R script file and extract the defined process.
#' @param path directory path to the R script file.
#' @param default a default process list to merge with the process read from the script file.
#' @return a list of processes defined in the R script file.
#' @note documentation generated by chatGPT
#' @export
sourceProcess = function (path, default=NULL) {
    assign("CARD", new.env(), envir=.GlobalEnv)
    source(path, encoding='UTF-8')
    lsCARD = ls(envir=CARD)

    Process_def = lsCARD[grepl("P[.]", lsCARD)]
    Process = lapply(Process_def, get, envir=CARD)
    names(Process) = gsub("P[.]", "", Process_def)
    Process = list(Process)
    names(Process) = "P"
    
    if (!is.null(default)) {
        nOK = !(names(default$P) %in% names(Process$P))
        Process$P = append(Process$P, default$P[nOK])
    }
    
    process_allAtt = lsCARD[grepl("P[[:digit:]][.]", lsCARD)]
    process_allNames = stringr::str_extract(process_allAtt,
                                            "P[[:digit:]]")
    process_names = process_allNames[!duplicated(process_allNames)]
    Nprocess = length(process_names)

    for (i in 1:Nprocess) {
        process_name = paste0("P", i)
        IDprocess = grepl(paste0(process_name, "[.]"),
                          process_allAtt)

        process_att = process_allAtt[IDprocess]
        process = lapply(process_att, get, envir=CARD)
        
        names(process) = gsub("P[[:digit:]][.]", "",
                              process_att)
        process = list(process)
        names(process) = process_name

        if (!is.null(default)) {
            nOK = !(names(default$P1) %in%
                    names(process[[process_name]]))
            process[[process_name]] =
                append(process[[process_name]], default$P1[nOK])
        }
        Process = append(Process, process)
    }

    rm (list=ls(envir=CARD), envir=CARD)
    return (Process)
}
