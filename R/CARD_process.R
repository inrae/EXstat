# Copyright 2021-2023 Louis Héraut (louis.heraut@inrae.fr)*1,
#                     Éric Sauquet (eric.sauquet@inrae.fr)*1,
#           2023 Jean-Philippe Vidal (jean-philippe.vidal@inrae.fr)*1,
#                Nathan Pellerin (nathan.pellerin@inrae.fr)*1
#
# *1   INRAE, France
#
# This file is part of EXstat R package.
#
# EXstat R package is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# EXstat R package is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with EXstat R package.
# If not, see <https://www.gnu.org/licenses/>.


#' @title CARD_extraction
#' @description The function extract specified data from a set of script files.
#' @param data Tibble used in the extraction
#' @param CARD_path directory path where CARD_dir is located
#' @param CARD_dir default="WIP", specify the name of the subdirectory in which to find the script files.
#' @param CARD_name specify the name of the script files to be used
#' @param period specify a period to extract from data
#' @param samplePeriod_by_topic specify a sample period per topic
#' @param simplify_by specify whether or not to simplify the extracted data by a column name
#' @param verbose default=FALSE, if set to TRUE, the function will print out the process details
#' @return a list of extracted data, along with meta data.
#' @note documentation generated by chatGPT
#' @export
CARD_extraction = function (data, CARD_path, CARD_dir="WIP", CARD_name=NULL,
                            period=NULL, samplePeriod_by_topic=NULL,
                            simplify_by=NULL,
                            verbose=FALSE) {
    
    CARD_dirpath = file.path(CARD_path, CARD_dir)   
    script_to_analyse = list.files(CARD_dirpath,
                                   pattern=".R$",
                                   recursive=TRUE,
                                   include.dirs=FALSE,
                                   full.names=FALSE)

    if (!is.null(CARD_name)) {
        script_to_analyse = script_to_analyse[script_to_analyse %in% CARD_name]
    }
    
    script_to_analyse = script_to_analyse[!grepl("__default__.R",
                                                 script_to_analyse)]

    topic_to_analyse = list.dirs(CARD_dirpath,
                                 recursive=TRUE, full.names=FALSE)
    topic_to_analyse = topic_to_analyse[topic_to_analyse != ""]
    topic_to_analyse = gsub('.*_', '', topic_to_analyse)

    structure = replicate(length(topic_to_analyse), c())
    names(structure) = topic_to_analyse

    var_analyse = c()

    metaEX = dplyr::tibble()
    dataEX = list()
    
    for (script in script_to_analyse) {

        list_path = list.files(file.path(CARD_path,
                                         "__tools__"),
                               pattern='*.R$',
                               recursive=TRUE,
                               # include.dirs=FALSE,
                               full.names=TRUE)
        for (path in list_path) {
            source(path, encoding='UTF-8')    
        }

        Process_default = sourceProcess(
            file.path(CARD_path, "__default__.R"))
        
        Process = sourceProcess(
            file.path(CARD_dirpath, script),
            default=Process_default)

        principal = Process$P
        principal_names = names(principal)
        for (i in 1:length(principal)) {
            assign(principal_names[i], principal[[i]])
        }
        
        split_script = split_path(script)
        
        if (length(split_script) == 1) {
            if (!('None' %in% names(structure))) {
                structure = append(list(None=c()), structure)
            }
            structure[['None']] = c(structure[['None']], var)
        } else if (length(split_script) == 2) {
            dir = split_script[2]
            dir = gsub('.*_', '', dir)
            structure[[dir]] = c(structure[[dir]], var)
        }
        
        if (!is.null(samplePeriod_by_topic)) {
            nProcess = length(Process)
            for (i in 1:nProcess) {
                if (!is.null(Process[[i]]$samplePeriod)) {
                    Process[[i]]$samplePeriod = samplePeriod_by_topic[[topic[1]]]
                    samplePeriod = Process[[i]]$samplePeriod
                }
            }
        }

        if (any(var %in% var_analyse)) {
            next
        }
        
        var_analyse = c(var_analyse, var)

        if (verbose) {
            print(paste0('Computes ', Process$P$var))
        }

        dataEX_tmp = data

        nProcess = length(Process) - 1

        for (i in 1:nProcess) {

            if (verbose) {
                print(paste0("Process ", i, "/", nProcess))
            }
            
            process = Process[[paste0("P", i)]]
            process_names = names(process)
            for (i in 1:length(process)) {
                assign(process_names[i], process[[i]])
            }

            # EXtraction
            dataEX_tmp = do.call(
                what=process_extraction,
                args=list(data=dataEX_tmp,
                          funct=funct,
                          funct_args=funct_args,
                          timeStep=timeStep,
                          samplePeriod=samplePeriod,
                          period=period,
                          isDate=isDate,
                          NApct_lim=NApct_lim,
                          NAyear_lim=NAyear_lim,
                          Seasons=Seasons,
                          onlyDate4Season=onlyDate4Season,
                          nameEX=nameEX,
                          keep=keep,
                          compress=compress,
                          rmNApct=rmNApct,
                          verbose=verbose))
        }

        if (verbose) {
            print(paste0("Data extracted for ", var))
            print(dataEX_tmp)
        }
        
        dataEX = append(dataEX, list(dataEX_tmp))
        names(dataEX)[length(dataEX)] = paste0(var, collapse=" / ")

        if (compress) {
            if (timeStep == "season") {
                var = sapply(X=Seasons, gsub, pattern="SEA", x=var)
            } else if (timeStep == "month") {
                var = sapply(X=1:12, gsub, pattern="MON", x=var)
            }
        }

        metaEX = dplyr::bind_rows(
                            metaEX,
                            dplyr::tibble(var=var,
                                          unit=unit,
                                          glose=glose,
                                          topic=
                                              paste0(topic,
                                                     collapse="/"),
                                          samplePeriod=
                                              paste0(samplePeriod,
                                                     collapse="/")))
    }
    
    if (!is.null(simplify_by)) {
        dataEX = purrr::reduce(.x=dataEX, .f=full_join, by=simplify_by)
    }
    res = list(metaEX=metaEX, dataEX=dataEX)
    return (res)
}


#' @title CARD_trend
#' @description The function applies trend analysis on the extracted data. It uses the CARD_extraction function to extract data first.
#' @param data Tibble used in the extraction
#' @param CARD_path directory path where CARD_dir is located
#' @param CARD_dir default="WIP", specify the name of the subdirectory in which to find the script files.
#' @param CARD_name specify the name of the script files to be used
#' @param simplify_by specify whether or not to simplify the extracted data
#' @param level default=0.1, level for the trend analysis
#' @param period specify a period to extract from data
#' @param samplePeriod_by_topic specify a sample period per topic
#' @param verbose default=TRUE, if set to TRUE, the function will print out the process details
#' @return a list of extracted data, meta data, and trend data.
#' @note documentation generated by chatGPT
#' @export
CARD_trend = function (data, CARD_path, CARD_dir="WIP", CARD_name=NULL,
                       simplify_by=NULL,
                       level=0.1, period=NULL, samplePeriod_by_topic=NULL,
                       verbose=TRUE) {

    if (verbose) {
        print(paste0('Computes ', 'trend'))
    }

    res = CARD_extraction(data,
                          CARD_path=CARD_path,
                          CARD_dir=CARD_dir,
                          CARD_name=CARD_name,
                          period=period,
                          samplePeriod_by_topic=samplePeriod_by_topic,
                          simplify_by=simplify_by, verbose=verbose)
    dataEX = res$dataEX
    metaEX = res$metaEX
    
    # Compute the trend analysis
    trendEX = process_trend(data=dataEX,
                            MK_level=level,
                            timeDep_option="AR1",
                            verbose=verbose)
        
    # Creates a list of results to return
    res = list(metaEX=metaEX,
               dataEX=dataEX,
               trendEX=trendEX)
    
    return (res)
}


#' @title sourceProcess
#' @description The function reads an R script file and extract the defined process.
#' @param path directory path to the R script file.
#' @param default a default process list to merge with the process read from the script file.
#' @return a list of processes defined in the R script file.
#' @note documentation generated by chatGPT
#' @export
sourceProcess = function (path, default=NULL) {
    assign("CARD", new.env(), envir=.GlobalEnv)
    source(path, encoding='UTF-8')
    lsCARD = ls(envir=CARD)

    Process_def = lsCARD[grepl("P[.]", lsCARD)]
    Process = lapply(Process_def, get, envir=CARD)
    names(Process) = gsub("P[.]", "", Process_def)
    Process = list(Process)
    names(Process) = "P"
    
    if (!is.null(default)) {
        nOK = !(names(default$P) %in% names(Process$P))
        Process$P = append(Process$P, default$P[nOK])
    }
    
    process_allAtt = lsCARD[grepl("P[[:digit:]][.]", lsCARD)]
    process_allNames = stringr::str_extract(process_allAtt,
                                            "P[[:digit:]]")
    process_names = process_allNames[!duplicated(process_allNames)]
    Nprocess = length(process_names)

    for (i in 1:Nprocess) {
        process_name = paste0("P", i)
        IDprocess = grepl(paste0(process_name, "[.]"),
                          process_allAtt)

        process_att = process_allAtt[IDprocess]
        process = lapply(process_att, get, envir=CARD)
        
        names(process) = gsub("P[[:digit:]][.]", "",
                              process_att)
        process = list(process)
        names(process) = process_name

        if (!is.null(default)) {
            nOK = !(names(default$P1) %in%
                    names(process[[process_name]]))
            process[[process_name]] =
                append(process[[process_name]], default$P1[nOK])
        }
        Process = append(Process, process)
    }

    rm (list=ls(envir=CARD), envir=CARD)
    return (Process)
}
