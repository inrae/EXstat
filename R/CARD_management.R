# Copyright 2021-2023 Louis Héraut (louis.heraut@inrae.fr)*1,
#                     Éric Sauquet (eric.sauquet@inrae.fr)*1,
#           2023 Jean-Philippe Vidal (jean-philippe.vidal@inrae.fr)*1,
#                Nathan Pellerin (nathan.pellerin@inrae.fr)*1
#
# *1   INRAE, France
#
# This file is part of EXstat R package.
#
# EXstat R package is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# EXstat R package is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with EXstat R package.
# If not, see <https://www.gnu.org/licenses/>.


remind = function (args) {
    write("PARAMETERS:", stdout())
    n = length(args)
    args_name = names(args)
    for (i in 1:n) {
        write(paste0("    --", args_name[i], " ",
                     paste0(args[[i]], collapse=" ")), stdout())
    }
}


#' @title CARD_management
#' @description This function manages the CARD directory structure and performs file operations based on the specified arguments.
#'
#' @param CARD The CARD directory path.
#' @param tmp The temporary directory path. If not provided, it will default to the value of `CARD`.
#' @param layout A character vector specifying the layout of files to be managed. The default layout is c("EX", "[", "QA", "]").
#' @param white Logical. If TRUE, underscores in file names will be replaced with spaces. Default is TRUE.
#' @param blank Logical. If TRUE, blank spaces will be added to the file names. Default is FALSE.
#' @param overwrite Logical. If TRUE, existing files in the temporary directory will be overwritten. Default is TRUE.
#' @param verbose Logical. If TRUE, intermediate messages will be printed during the execution of the function. Default is FALSE.
#' @param args A list of arguments needed for the function. If not provided, it will be automatically created using the other function arguments.
#'
#' @note documentation generated by chatGPT
#' 
#' @examples
#' # Manage CARD directory with default arguments
#' CARD_management(CARD = "/path/to/CARD")
#'
#' # Manage CARD directory with custom arguments
#' CARD_management(CARD = "/path/to/CARD", tmp = "/path/to/tmp", layout = c("EX", "[", "QA", "]"),
#'                 white = TRUE, blank = FALSE, overwrite = TRUE, verbose = TRUE)
#'
#' @keywords file management, directory management
CARD_management = function (CARD=".", tmp="",
                            layout=c("EX", "[", "QA", "]"), white=TRUE,
                            blank=FALSE, overwrite=TRUE,
                            verbose=FALSE, args=NULL) {
    
    if (is.null(args)) {
        args = list(CARD=CARD, tmp=tmp, layout=layout,
                    white=white, blank=blank, overwrite=overwrite,
                    verbose=verbose)        
    }

    if (args$tmp == "") {
        args$tmp = args$CARD
    }
        
    if (args$verbose) {
        remind(args)
    }
    if (all(args$layout == "")) {
        write("Error : --layout is void\n", stderr())
        stop ()
    }

    source_dir = file.path(args$CARD, "__all__")

    OUT = unlist(args$layout)
    nOUT = length(OUT)
    test1 = "[[]|[(]|[]]|[)]"
    test2 = "[[]|[(]"
    for (i in 1:nOUT) {
        if (i < nOUT & !grepl(test1, OUT[i]) & !grepl(test2, OUT[(i+1)])) {
            OUT[i] = paste0(OUT[i], ".(NA)")
        }
        if (i == nOUT & !grepl(test1, OUT[(i)])) {
            OUT[i] = paste0(OUT[i], ".(NA)")
        }
    }
    OUT = unlist(sapply(OUT, strsplit, split="[.]"),
                 use.names=FALSE)

    OUT = paste0(OUT, collapse="','")
    OUT = gsub("[]]", ")", OUT)
    OUT = gsub("[[]|[(]", "=list(", OUT)
    OUT = gsub("[,]['][=]", "=", OUT)
    OUT = gsub("[(]['][,]", "(", OUT)
    OUT = gsub("[,]['][)]", ")", OUT)
    OUT = gsub("[)][']", ")", OUT)
    OUT = paste0("'", OUT)
    OUT = paste0("list(", OUT, ")")    
    OUT = eval(parse(text=OUT))
    OUT = unlist(OUT)
    OUT = names(OUT)
    OUT = gsub("[.]", "/", OUT)
    OUT = paste0(OUT, ".R")

    n = length(OUT)
    SUB = c()
    save = c()
    IN = c()
    DIR = c()
    for (i in 1:n) {
        path = unlist(strsplit(OUT[i], "/"))
        len = length(path)
        nsd = len - 2

        if (nsd < 0) {
            write("Error : No tmp detect\n", stderr())
            stop ()
            
        } else if (nsd == 0) {
            id = i
            
        } else if (nsd > 0) {

            for (j in 1:nsd) {
                
                if (!(path[(j+1)] %in% save)) {

                    if (length(SUB) >= nsd) {
                        if (any(path %in% save)) {
                            SUB[sum(path %in% save)] =
                                SUB[sum(path %in% save)] + 1
                            SUB[(sum(path %in% save)+1):length(SUB)] = 1
                        } else {
                            SUB[nsd] = SUB[nsd] + 1
                        }
                    } else {
                        SUB = c(SUB, 1)
                    }
                    id = 1
                    save = c(save, path[(j+1)])
                }

                obj = path[(j+1)]
                if (args$white) {
                    obj = gsub("[_]", " ", obj)
                }

                if (!args$blank) {
                    path[(j+1)] = paste0(formatC(SUB[j],
                                                 width=3,
                                                 flag="0"),
                                         "_", obj)
                }
            }
        }
        
        IN = c(IN, path[len])
        DIR = c(DIR, do.call(file.path, as.list(path[-len])))
        
        if (!args$blank) {
            idC = formatC(id, width=3, flag="0")
            path[len] = paste0(idC, "_", path[len])
        }
        
        id = id + 1
        OUT[i] = do.call(file.path, as.list(path))
    }

    DIR = DIR[!duplicated(DIR)]
    DIR = file.path(args$tmp, DIR)

    print(DIR)
    print(any(file.exists(DIR, recursive=TRUE)))
    print(args$overwrite)
    print(!any(file.exists(DIR, recursive=TRUE)))
    print("")
    print(any(file.exists(DIR, recursive=TRUE)))
    print("")
    
    if (any(file.exists(DIR, recursive=TRUE)) &
        args$overwrite |
        !any(file.exists(DIR, recursive=TRUE))) {
        if (any(file.exists(DIR, recursive=TRUE)) &
            args$overwrite) {
            unlink(DIR, recursive=TRUE, force=TRUE)
        }
        for (i in 1:n) {
            dir.create(DIR[i], recursive=TRUE)
        }

        for (i in 1:n) {
            files = list.files(source_dir, recursive=TRUE)
            names(files) = basename(files)

            print(file.path(source_dir, files[IN[i]]))
            print(file.path(args$tmp, OUT[i]))
            
            file.copy(file.path(source_dir, files[IN[i]]),
                      file.path(args$tmp, OUT[i]))
        }
    }

    if (args$verbose) {
        write("done", stdout())
    }
}
