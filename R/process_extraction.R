# Copyright 2021-2023 Louis Héraut (louis.heraut@inrae.fr)*1,
#                     Éric Sauquet (eric.sauquet@inrae.fr)*1,
#           2023 Jean-Philippe Vidal (jean-philippe.vidal@inrae.fr)*1
#
# *1   INRAE, France
#
# This file is part of EXstat R package.
#
# EXstat R package is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# EXstat R package is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with EXstat R package.
# If not, see <https://www.gnu.org/licenses/>.


#' @title process_extraction
#' @description This process extract a variable from time series (for
#' example the yearly mean of time series). Extraction can be yearly,
#' monthly or realised each month of every year and sampled
#' differently along years or months.
#' @param data Input data format is a tibble of at least a column of
#' date, a column of numeric value and a character column for names of
#' time series in order to identify them. Thus it is possible to have
#' a tibble with multiple time series which can be grouped by their
#' names.
#' @param funct The function (for example `mean`) that you want to
#' use. Arguments of the chosen function can be passed to this
#' extraction process and the function can be previously defined.
#' @param period A vector of two date to restrict the period of
#' analysis. Imposed date format is "YYYY-mm-dd". As an example it can
#' be c("1950-01-01", "2020-12-31") to select data from the 1st
#' january of 1950 to the end of december of 2020. The default option
#' is period=NULL which considers all available data.
#' @param isDate logical, if TRUE, function will assume that Date is a
#' date and not a numeric value.
#' @param NApct_lim numeric, maximum percentage of missing values in the time serie allowed.
#' @param NAyear_lim numeric, maximum number of missing years allowed.
#' @param Seasons vector of 4 characters, the default season set is "DJF", "MAM", "JJA", "SON"
#' @param onlyDate4Season logical, if TRUE, seasons computation will be based only on date.
#' @param nameEX character, name of the extracted variable
#' @param keep a character vector of column names to keep in the output dataframe.
#' @param compress logical. Should the function return a tibble or a compressed tibble?
#' @param rmNApct logical. Should rows with a high percentage of missing values be removed?
#' @param ... Arguments needed for the function provided through \code{funct}.
#' @examples
#' # Date
#' Start = as.Date("1972-01-01")
#' End = as.Date("2020-12-31")
#' Date = seq.Date(Start, End, by="day")
#' 
#' # Value to analyse
#' set.seed(100)
#' X = seq(1, length(Date))/1e4 + runif(length(Date), -100, 100)
#' X[as.Date("2000-03-01") <= Date & Date <= as.Date("2000-09-30")] = NA
#'
#' # Creation of tibble
#' data = dplyr::tibble(Date=Date, ID="serie A", X=X)
#'
#' # Extraction
#' dataEX = process_extraction(data=data,
#'                             samplePeriod=c("05-01",
#'                                            "11-30"),
#'                             funct=max,
#'                             na.rm=TRUE,
#'                             period=c(as.Date("1990-01-01"),
#'                                      as.Date("2020-12-31")),
#'                             timeStep="year")
#' dataEX
#' @importFrom rlang .data
#' @note documentation generated by chatGPT
#' @export
process_extraction = function(data,
                              funct=max,
                              funct_args=list(),
                              timeStep="year",
                              samplePeriod=NULL,
                              period=NULL,
                              isDate=FALSE,
                              NApct_lim=10,
                              NAyear_lim=10,
                              Seasons=c("DJF", "MAM", "JJA", "SON"),
                              onlyDate4Season=FALSE,
                              nameEX="X",
                              keep=NULL,
                              compress=FALSE,
                              rmNApct=FALSE,
                              verbose=FALSE, 
                              ...) {

    mDay = c(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
    
    tree("EXTRACTION PROCESS", 0, verbose=verbose)

    if (is.character(period)) {
        period = as.Date(period)
    }
    
    names_save = names(data)
    idValue_save = c()
    for (id in 1:ncol(data)) {
        x = data[[id]]

        if (is.character(x)) {
            idCode_save = id
        } else if (lubridate::is.Date(x)) {
            idDate_save = id
        } else if (is.numeric(x)) {
            idValue_save = c(idValue_save, id)
        }
    }

    if (!exists("idDate_save")) {
        idDate_save = NULL
    }

    if (!is.null(keep)) {
        idValue_keepSave = idValue_save
        names_keepSave = names_save
    }
    
    nValue = length(idValue_save)
    colName = paste0("Value", 1:nValue)

    if (is.function(funct)){
        funct = list(funct)
    }
    if (!is.list(funct_args[[1]])) {
        funct_args = list(funct_args)
    }
    
    nfunct = length(funct)
    
    colArgs_save = list()
    colArgs = list()
    otherArgs = list()
    isColArgs = list()
    colArgs_order = list()
    for (i in 1:nfunct) {
        arg = funct_args[[i]]
        colArgs_save = append(colArgs_save,
                              list(arg[arg %in% names_save]))
        otherArgs = append(otherArgs,
                           list(arg[!(arg %in% names_save)]))
        isColArgs = append(isColArgs, any(arg %in% names_save))

        if (isColArgs[[i]]) {
            colArgs_order = append(colArgs_order,
                                   list(match(colArgs_save[[i]],
                                              names_save[idValue_save])))
            colArgs = append(colArgs,
                             list(paste0("Value",
                                         colArgs_order[[i]])))
            names(colArgs[[i]]) =
                names(colArgs_save[[i]])
        }
    }

    if (length(colArgs) == 0) {
        stop (paste0("Are the given parameters that refer to column names spelled correctly ? ",
                     funct_args, " is given but only names in ",
                     paste0(names(data)[idValue_save], collapse=", "),
                     " are possible."))
    }

    dataEX = data

    if (!is.null(idDate_save)) {
        names(dataEX)[c(idCode_save, idDate_save, idValue_save)] =
            c("Code", "Date", unlist(colName))
    } else {
        names(dataEX)[c(idCode_save, idValue_save)] =
            c("Code", unlist(colName))
    }
    
    if (any(unlist(isColArgs))) {

        if (!is.null(names(funct)) & all(names(funct) != "")) {
            nameEX = names(funct)
        } else {
            if (length(nameEX) != nfunct) {
                nameEX = paste0(nameEX[1], 1:nfunct)
            }
        }

        if (nValue > nfunct) {
            names_save = names_save[-c(idValue_save[(nfunct+1):nValue])]
            idValue_save = idValue_save[1:nfunct]
            
        } else if (nValue < nfunct) {
            idValue_save = idValue_save[1:nfunct]
            isNA = is.na(idValue_save)
            nNA = sum(isNA)
            maxId = max(idValue_save, na.rm=TRUE)
            idValue_save[isNA] = (maxId + 1):(maxId + nNA)
        }
        
        names_save[idValue_save[1:nfunct]] = nameEX
    }

    if (!is.null(NAyear_lim) & !is.null(idDate_save)) {
        dataEX = missing_year(dataEX, nValue, NAyear_lim,
                              verbose=verbose)
    }
    
    tree("Period", 1, verbose=verbose)
    if (is.null(period) | is.null(idDate_save)) {
        tree("Selecting all the data",
             2, TRUE, verbose=verbose)
    } else {
        tree(paste0("Selecting data between ",
                    format(period[1], "%d %b %Y"),
                    " and ",
                    format(period[2], "%d %b %Y")),
             2, TRUE, verbose=verbose)
        dataEX = dplyr::filter(dataEX, period[1] <= Date & Date <= period[2])
    }

    if (timeStep %in% c("year", "none")) {
        refDate = "1972"
        sampleFormat = "%m-%d"

    } else if (timeStep %in% c("yearday",
                               "month", "year-month",
                               "season", "year-season")) {
        refDate = "1972-01"
        sampleFormat = "%d"
    }

    Code = names(table(dataEX$Code))

    tree("Sample period", 1, verbose=verbose)

    if (is.null(samplePeriod) | all(is.na(samplePeriod))) {
        tree("Default sample period used", 2,
             verbose=verbose)
        if (timeStep %in% c("year", "none")) {
            samplePeriod = "01-01"
        } else if (timeStep %in% c("yearday",
                                   "month", "year-month",
                                   "season", "year-season")) {
            samplePeriod = "01"
        }
    }

    if (dplyr::is.tbl(samplePeriod)) {
        idCode = which((names(samplePeriod) %in% names_save))
        idSP = which(!(names(samplePeriod) %in% names_save))
        names(samplePeriod)[c(idCode, idSP)] = c("Code", "sp")
        samplePeriod = samplePeriod[samplePeriod$Code %in% Code,]
        
        tree("Fixing sample period for each time series", 2,
             verbose=verbose)
        samplePeriod$sp = lapply(samplePeriod$sp,
                                 fix_samplePeriod,
                                 refDate=refDate,
                                 sampleFormat=sampleFormat,
                                 verbose=FALSE)        
        
    } else {

        d = try(as.Date(paste0(refDate, "-", samplePeriod),
                        format="%Y-%m-%d"))        
        if ("try-error" %in% class(d) || any(is.na(d))) {
            if (timeStep %in% c("year", "none")) {
                stop ("'samplePeriod' given is not in the right format. You should use two valid number to select a month and a day of the year separated by a '-' for the starting (and/or ending) of the sample period (i.e. '02-10' for the 10th of february). See documentation.")
            } else {
                stop ("'samplePeriod' given is not in the right format. You should use one valid number to select a day of a month for the starting (and/or ending) of the sample period (i.e. '10' for the 10th day of the month). See documentation.")
            }
        }

        if (is.character(samplePeriod)) {
            tree("Fixing sample period", 2, end=TRUE,
                 verbose=verbose)
            samplePeriod = fix_samplePeriod(samplePeriod,
                                            refDate=refDate,
                                            sampleFormat=sampleFormat,
                                            verbose=verbose)
            
        } else {
            tree("Sample period fully given", 2, end=TRUE,
                 verbose=verbose)
        }
        samplePeriod = dplyr::tibble(Code=Code,
                                     sp=rep(list(samplePeriod),
                                            length(Code)))
    }

    samplePeriod$spStart = sapply(samplePeriod$sp, "[[", 1)
    samplePeriod$spEnd = sapply(samplePeriod$sp, "[[", 2)
    
    samplePeriod$refStart = as.Date(paste0(refDate,
                                           '-',
                                           samplePeriod$spStart))
    samplePeriod$refEnd = as.Date(paste0(refDate,
                                         '-',
                                         samplePeriod$spEnd))

    if (length(samplePeriod$spStart[!duplicated(samplePeriod$spStart)]) == 1 & length(samplePeriod$spEnd[!duplicated(samplePeriod$spEnd)]) == 1) {
        
        tree("Every time series have the same sample period", 3, inEnd=2, verbose=verbose)
        tree(paste0("All : ", samplePeriod$spStart[1],
                    " / ", samplePeriod$spEnd[1]),
             3, end=TRUE, inEnd=2, verbose=verbose)
        
    } else {
        toTree = paste0(samplePeriod$Code, " : ",
                        samplePeriod$spStart,
                        " / ",
                        samplePeriod$spEnd)
        
        nToTree = length(toTree)
        for (t in 1:nToTree) {
            if (t == nToTree) {
                end = TRUE
            } else {
                end = FALSE
            }
            tree(toTree[t], 3, end=end, inEnd=2, verbose=verbose)
        }
    }

    samplePeriod$dt2add = 0
    samplePeriod$dt2add[samplePeriod$refStart >= samplePeriod$refEnd] = 1

    dataEX = dplyr::full_join(dataEX,
                              samplePeriod[c("Code",
                                             "spStart",
                                             "spEnd",
                                             "refStart",
                                             "refEnd",
                                             "dt2add")],
                              by="Code")
    
    if (timeStep == "none") {

        tree("None extraction", 1, verbose=verbose)
        tree("Sampling of the data", 2, verbose=verbose)
        
        samplePeriod$dRef =
            as.numeric(samplePeriod$refStart +
                       lubridate::years(abs(samplePeriod$dt2add-1)) -
                       samplePeriod$refEnd)

        if (any(samplePeriod$dRef != 1)) {
            
            samplePeriod$mStart =
                as.numeric(substr(samplePeriod$spStart, 1, 2))
            samplePeriod$dStart =
                as.numeric(substr(samplePeriod$spStart, 4, 5))
            samplePeriod$mEnd =
                as.numeric(substr(samplePeriod$spEnd, 1, 2))
            samplePeriod$dEnd =
                as.numeric(substr(samplePeriod$spEnd, 4, 5))
            
            dataEX = dplyr::full_join(dataEX,
                                      samplePeriod[c("Code",
                                                     "mStart",
                                                     "dStart",
                                                     "mEnd",
                                                     "dEnd")],
                                      by="Code")
            
            dataEX = dplyr::filter(dataEX,
                                   
            (refStart < refEnd)
            & (mStart < lubridate::month(Date)
                | (mStart == lubridate::month(Date)
                    & dStart <= lubridate::day(Date)))
            & (lubridate::month(Date) < mEnd
                | (lubridate::month(Date) == mEnd
                    & lubridate::day(Date) <= dEnd))
            
            |
            
            (refStart >= refEnd)
            & ((lubridate::month(Date) < mEnd
                | (lubridate::month(Date) == mEnd
                    & lubridate::day(Date) <= dEnd))
                | (mStart < lubridate::month(Date)
                    | (mStart == lubridate::month(Date)
                        & dStart <= lubridate::day(Date))))
            
            )
            
            dataEX = dplyr::select(dataEX, -c(mStart,
                                              dStart,
                                              mEnd,
                                              dEnd))
        }
        
        dataEX = dplyr::select(dataEX, -c(spStart,
                                          spEnd,
                                          refStart,
                                          refEnd,
                                          dt2add))

        if (!is.null(keep)) {
            dataEX_save = dataEX
        }

    } else if (timeStep == "year") {
        tree("Yearly extraction", 1, verbose=verbose)
        tree("Sampling of the data", 2, verbose=verbose)

        samplePeriod$dRef =
            as.numeric(samplePeriod$refStart +
                       lubridate::years(abs(samplePeriod$dt2add-1)) -
                       samplePeriod$refEnd)

        if (any(samplePeriod$dRef != 1)) {
            
            samplePeriod$mStart =
                as.numeric(substr(samplePeriod$spStart, 1, 2))
            samplePeriod$dStart =
                as.numeric(substr(samplePeriod$spStart, 4, 5))
            samplePeriod$mEnd =
                as.numeric(substr(samplePeriod$spEnd, 1, 2))
            samplePeriod$dEnd =
                as.numeric(substr(samplePeriod$spEnd, 4, 5))
            
            dataEX = dplyr::full_join(dataEX,
                                      samplePeriod[c("Code",
                                                     "mStart",
                                                     "dStart",
                                                     "mEnd",
                                                     "dEnd")],
                                      by="Code")
            
            dataEX = dplyr::filter(dataEX,
                                   
            (refStart < refEnd)
            & (mStart < lubridate::month(Date)
                | (mStart == lubridate::month(Date)
                    & dStart <= lubridate::day(Date)))
            & (lubridate::month(Date) < mEnd
                | (lubridate::month(Date) == mEnd
                    & lubridate::day(Date) <= dEnd))
            
            |
            
            (refStart >= refEnd)
            & ((lubridate::month(Date) < mEnd
                | (lubridate::month(Date) == mEnd
                    & lubridate::day(Date) <= dEnd))
                | (mStart < lubridate::month(Date)
                    | (mStart == lubridate::month(Date)
                        & dStart <= lubridate::day(Date))))
            
            )
            
            dataEX = dplyr::select(dataEX, -c(mStart,
                                              dStart,
                                              mEnd,
                                              dEnd))
        }
        
        dataEX = dplyr::select(dataEX, -c(refStart,
                                          refEnd))

        if (!is.null(keep)) {
            dataEX_save = dplyr::select(dataEX, -c(spStart,
                                                   spEnd,
                                                   dt2add))
        }

        tree("Preparing date data for the extraction",
             end=TRUE, 2, verbose=verbose)
        tree("Computing of time indicators for each time serie",
             3, inEnd=2, verbose=verbose)

        sampleInfo =
            dplyr::summarise(dplyr::group_by(dataEX, Code),
                             minDate=min(Date),
                             .groups="drop")
        
        sampleInfo =
            dplyr::summarise(dplyr::group_by(dataEX, Code),
                             minDate=min(Date),
                             minDateRef=
                                 as.Date(paste0(
                                     lubridate::year(minDate),
                                     "-01-01")),
                             spStart=spStart[1],
                             minSampleStart=
                                 as.Date(paste0(
                                     lubridate::year(minDate),
                                     "-",
                                     spStart[1])),
                             maxDate=max(Date),
                             spEnd=spEnd[1],
                             maxSampleEnd=
                                 lubridate::add_with_rollback(
                                                as.Date(paste0(
                                                    lubridate::year(maxDate),
                                                    "-",
                                                    spEnd[1])),
                                                lubridate::years(dt2add[1])),
                             .groups="drop")
        
        tree("Shifting the start of each year in order to speed extraction process", 3, inEnd=2, verbose=verbose)

        sampleInfo$isAfterFeb =
            as.Date(paste0(refDate, "-", sampleInfo$spStart)) >
            as.Date(paste0(refDate, "-02-28"))
        
        sampleInfo$Shift =
            lubridate::yday(as.Date(paste0(refDate,
                                           "-",
                                           sampleInfo$spStart))) - 1

        sampleInfo$Shift[sampleInfo$isAfterFeb] =
            sampleInfo$Shift[sampleInfo$isAfterFeb] - 1

        dataEX = dplyr::full_join(dataEX, sampleInfo[c("Code",
                                                       "Shift")],
                                  by=c("Code"))

        dataEX$Year = lubridate::year(dataEX$Date)
        Add4LeapYear =
            dplyr::summarise(
                       dplyr::group_by(dataEX,
                                       Code,
                                       spStart,
                                       Year),
                       isLeapYear=check_leapYear(Year[1]),
                       .groups="drop")


        Add4LeapYear = dplyr::full_join(Add4LeapYear,
                                        sampleInfo[c("Code",
                                                     "isAfterFeb")],
                                        by=c("Code"))

        Add4LeapYear$Add2Shift =
            as.numeric(Add4LeapYear$isAfterFeb &
                       Add4LeapYear$isLeapYear)

        dataEX = dplyr::full_join(dataEX,
                                  Add4LeapYear[c("Code",
                                                 "Year",
                                                 "Add2Shift")],
                                  by=c("Code", "Year"))

        dataEX$Shift = dataEX$Shift + dataEX$Add2Shift
        dataEX$Date = dataEX$Date - dataEX$Shift

        sampleInfo$dNAstart =
            pmax(0, as.numeric(sampleInfo$minDate -
                               sampleInfo$minSampleStart))
        sampleInfo$dNAend =
            pmax(0, as.numeric(sampleInfo$maxSampleEnd -
                               sampleInfo$maxDate))

        sampleStartInfo =
            sampleInfo[c("Code", "minDate", "dNAstart")]
        names(sampleStartInfo) = c("Code", "Date", "dNA")
        sampleEndInfo =
            sampleInfo[c("Code", "maxDate", "dNAend")]
        names(sampleEndInfo) = c("Code", "Date", "dNA")

        sampleInfoCompress = dplyr::bind_rows(sampleStartInfo,
                                              sampleEndInfo)

        sampleInfoCompress$Date =
            as.Date(paste0(lubridate::year(sampleInfoCompress$Date),
                           "-01-01"))

        dataEX = dplyr::full_join(dataEX,
                                  sampleInfo[c("Code",
                                               "minDateRef")],
                                  by=c("Code"))

        tree("Removing useless data", 3, end=TRUE, inEnd=2,
             verbose=verbose)

        dataEX = dplyr::select(dataEX, -c(Year,
                                          Shift,
                                          Add2Shift,
                                          spStart,
                                          spEnd,
                                          dt2add))
        
    } else if (timeStep == "yearday") {
        
        tree("Yearday extraction", 1, verbose=verbose)
        tree("Sampling of the data", 2, verbose=verbose)

        samplePeriod$dRef =
            as.numeric(samplePeriod$refStart +
                       months(abs(samplePeriod$dt2add-1)) -
                       samplePeriod$refEnd)

        if (any(samplePeriod$dRef != 1)) {
        
            samplePeriod$dStart = as.numeric(substr(samplePeriod$spStart, 1, 2))
            samplePeriod$dEnd = as.numeric(substr(samplePeriod$spEnd, 1, 2))
            
            dataEX = dplyr::full_join(dataEX,
                                      samplePeriod[c("Code",
                                                     "dStart",
                                                     "dEnd")],
                                      by="Code")
            
            dataEX = dplyr::filter(dataEX,
                                   
            (refStart < refEnd)
            & dStart <= lubridate::day(Date)
            & lubridate::day(Date) <= dEnd
            
            |
            
            (refStart >= refEnd)
            & (lubridate::day(Date) <= dEnd
                | dStart <= lubridate::day(Date))
            
            )
            
            dataEX = dplyr::select(dataEX, -c(dStart,
                                              dEnd))
        }

        dataEX = dplyr::select(dataEX, -c(refStart,
                                          refEnd))

        if (!is.null(keep)) {
            dataEX_save = dplyr::select(dataEX, -c(spStart,
                                                   spEnd,
                                                   dt2add))
        }

        tree("Preparing date data for the extraction",
             end=TRUE, 2, verbose=verbose)
        tree("Computing of time indicators for each time serie",
             3, inEnd=2, verbose=verbose)

        sampleInfo =
            dplyr::summarise(dplyr::group_by(dataEX, Code),
                             minDate=min(Date),
                             minDateRef=
                                 as.Date(paste0(
                                     lubridate::year(minDate),
                                     "-",
                                     lubridate::month(minDate),
                                     "-01")),
                             spStart=spStart[1],
                             maxDate=max(Date),
                             spEnd=spEnd[1],
                             .groups="drop")
        
        tree("Shifting the start of each year in order to speed extraction process", 3, inEnd=2, verbose=verbose)

        sampleInfo$isAfterFeb =
            as.Date(paste0(refDate, "-", sampleInfo$spStart)) >
            as.Date(paste0(refDate, "-02-28"))
        
        sampleInfo$Shift =
            lubridate::yday(as.Date(paste0(refDate,
                                           "-",
                                           sampleInfo$spStart))) - 1

        sampleInfo$Shift[sampleInfo$isAfterFeb] =
            sampleInfo$Shift[sampleInfo$isAfterFeb] - 1

        dataEX = dplyr::full_join(dataEX, sampleInfo[c("Code",
                                                       "Shift")],
                                  by=c("Code"))

        dataEX$Year = lubridate::year(dataEX$Date)
        Add4LeapYear =
            dplyr::summarise(
                       dplyr::group_by(dataEX,
                                       Code,
                                       spStart,
                                       Year),
                       isLeapYear=check_leapYear(Year[1]),
                       .groups="drop")


        Add4LeapYear = dplyr::full_join(Add4LeapYear,
                                        sampleInfo[c("Code",
                                                     "isAfterFeb")],
                                        by=c("Code"))

        Add4LeapYear$Add2Shift =
            as.numeric(Add4LeapYear$isAfterFeb &
                       Add4LeapYear$isLeapYear)

        dataEX = dplyr::full_join(dataEX,
                                  Add4LeapYear[c("Code",
                                                 "Year",
                                                 "Add2Shift")],
                                  by=c("Code", "Year"))

        dataEX$Shift = dataEX$Shift + dataEX$Add2Shift
        dataEX$Date = dataEX$Date - dataEX$Shift

        dataEX = dplyr::full_join(dataEX,
                                  sampleInfo[c("Code",
                                               "minDateRef")],
                                  by=c("Code"))
        
        tree("Removing useless data", 3, end=TRUE, inEnd=2,
             verbose=verbose)

        dataEX = dplyr::select(dataEX, -c(Year,
                                          Shift,
                                          Add2Shift,
                                          spStart,
                                          spEnd,
                                          dt2add))
        

    } else if (timeStep %in% c("month", "year-month")) {

        if (timeStep == "month") {
            tree("Monthly extraction", 1, verbose=verbose)
        } else if (timeStep == "year-month") {
            tree("Monthly extraction along years", 1, verbose=verbose)
        }
        tree("Sampling of the data", 2, verbose=verbose)

        samplePeriod$dRef =
            as.numeric(samplePeriod$refStart +
                       months(abs(samplePeriod$dt2add-1)) -
                       samplePeriod$refEnd)


        if (any(samplePeriod$dRef != 1)) {
        
            samplePeriod$dStart = as.numeric(substr(samplePeriod$spStart, 1, 2))
            samplePeriod$dEnd = as.numeric(substr(samplePeriod$spEnd, 1, 2))
            
            dataEX = dplyr::full_join(dataEX,
                                      samplePeriod[c("Code",
                                                     "dStart",
                                                     "dEnd")],
                                      by="Code")
            
            dataEX = dplyr::filter(dataEX,
                                   
            (refStart < refEnd)
            & dStart <= lubridate::day(Date)
            & lubridate::day(Date) <= dEnd
            
            |
            
            (refStart >= refEnd)
            & (lubridate::day(Date) <= dEnd
                | dStart <= lubridate::day(Date))
            
            )
            
            dataEX = dplyr::select(dataEX, -c(dStart,
                                              dEnd))
        }

        dataEX = dplyr::select(dataEX, -c(refStart,
                                          refEnd))

        if (!is.null(keep)) {
            dataEX_save = dplyr::select(dataEX, -c(spStart,
                                                   spEnd,
                                                   dt2add))
        }

        tree("Preparing date data for the extraction",
             end=TRUE, 2, verbose=verbose)
        tree("Computing of time indicators for each time serie",
             3, inEnd=2, verbose=verbose)

        if (timeStep == "year-month") {
            sampleInfo =
                dplyr::summarise(dplyr::group_by(dataEX, Code),
                                 minDate=min(Date),
                                 minDateRef=
                                     as.Date(paste0(
                                         lubridate::year(minDate),
                                         "-",
                                         lubridate::month(minDate),
                                         "-01")),
                                 spStart=spStart[1],
                                 minSampleStart=
                                     lubridate::add_with_rollback(
                                                    as.Date(paste0(
                                                        lubridate::year(minDate),
                                                        "-01-",
                                                        spStart[1])),
                                                    months(lubridate::month(minDate)
                                                           -1)),
                                 maxDate=max(Date),
                                 spEnd=spEnd[1],
                                 maxSampleEnd=
                                     lubridate::add_with_rollback(
                                                    as.Date(paste0(
                                                        lubridate::year(maxDate),
                                                        "-01-",
                                                        spEnd[1])),
                                                    months(lubridate::month(maxDate) + dt2add[1] - 1)),
                                 maxSampleStart=
                                     lubridate::add_with_rollback(
                                                    as.Date(paste0(
                                                        lubridate::year(maxDate),
                                                        "-01-",
                                                        spStart[1])),
                                                    months(lubridate::month(maxDate) - 1)),
                                 .groups="drop")
            
        } else if (timeStep == "month") {
            sampleInfo =
                dplyr::summarise(dplyr::group_by(dataEX, Code),
                                 minDate=min(Date),
                                 minDateRef=
                                     as.Date(paste0(
                                         lubridate::year(minDate),
                                         "-",
                                         lubridate::month(minDate),
                                         "-01")),
                                 spStart=spStart[1],
                                 minSampleStart=
                                     lubridate::add_with_rollback(
                                                    as.Date(paste0(
                                                        lubridate::year(minDate),
                                                        "-01-",
                                                        spStart[1])),
                                                    months(lubridate::month(minDate)
                                                           -1)),

                                 maxDate=max(Date),
                                 spEnd=spEnd[1],
                                 maxSampleEnd=
                                     lubridate::add_with_rollback(
                                                    as.Date(paste0(
                                                        lubridate::year(maxDate),
                                                        "-01-",
                                                        spEnd[1])),
                                                    months(lubridate::month(maxDate) + dt2add[1] - 1)),
                                 maxSampleStart=
                                     lubridate::add_with_rollback(
                                                    as.Date(paste0(
                                                        lubridate::year(maxDate),
                                                        "-01-",
                                                        spStart[1])),
                                                    months(lubridate::month(maxDate) - 1)),
                                 .groups="drop")

            monthInfo =
                dplyr::summarise(dplyr::group_by(dataEX,
                                                 Code,
                                                 YM=format(Date,
                                                           "%Y-%m")),
                                 Date=Date[!duplicated(YM)],
                                 .groups="drop")
            monthInfo =
                dplyr::summarise(
                           dplyr::group_by(monthInfo,
                                           Code,
                                           Date=format(Date, "%m")),
                           nYear=dplyr::n(),
                           .groups="drop")
        }

        tree("Shifting the start of each year in order to speed extraction process", 3, inEnd=2, verbose=verbose)
        
        sampleInfo$Shift =
            lubridate::mday(sampleInfo$minSampleStart) - 1
        dataEX = dplyr::full_join(dataEX,
                                  sampleInfo[c("Code",
                                               "Shift")],
                                  by=c("Code"))
        
        dataEX$Date = dataEX$Date - dataEX$Shift

        sampleInfo$dNAstart =
            pmax(0, as.numeric(sampleInfo$minDate -
                              sampleInfo$minSampleStart))
        sampleInfo$dNAend =
            pmax(0, as.numeric(sampleInfo$maxSampleEnd -
                              sampleInfo$maxDate))

        sampleStartInfo =
            sampleInfo[c("Code", "minSampleStart", "dNAstart")]
        names(sampleStartInfo) = c("Code", "Date", "dNA")
        sampleEndInfo =
            sampleInfo[c("Code", "maxSampleStart", "dNAend")]
        names(sampleEndInfo) = c("Code", "Date", "dNA")

        sampleInfoCompress = dplyr::bind_rows(sampleStartInfo,
                                              sampleEndInfo)

        dataEX = dplyr::full_join(dataEX,
                                  sampleInfo[c("Code",
                                               "minDateRef")],
                                  by=c("Code"))
        
        tree("Removing useless data", 3, end=TRUE, inEnd=2,
             verbose=verbose)
        dataEX = dplyr::select(dataEX, -c(Shift,
                                          spStart,
                                          spEnd))


        
    } else if (timeStep %in% c("season", "year-season")) {

        if (timeStep == "season") {
            tree("Seasonly extraction", 1, verbose=verbose)
        } else if (timeStep == "year-season") {
            tree("Seasonly extraction along years", 1, verbose=verbose)
        }
        tree(paste0("Creating of the conversion process from months ",
                    "to seasons based on seasons vector ",
                    paste0(Seasons, collapse=" - ")),
             2, verbose=verbose)
        nMonthSeasons = sapply(Seasons, nchar)
        
        get_Season = rep(Seasons, nMonthSeasons)
        
        idJan = (which(unlist(strsplit(paste0(Seasons,
                                              collapse=""),
                                       "")) == "D") + 1) %% 12
        
        get_Season = c(get_Season[idJan:12], get_Season[1:(idJan-1)])
        
        subSeasons = unlist(lapply(nMonthSeasons, seq, from=1)) - 1
        names(subSeasons) = NULL
        subSeasons = c(subSeasons[idJan:12],
                       subSeasons[1:(idJan-1)])

        addSeasons = unlist(lapply(nMonthSeasons, seq, to=1)) - 1
        names(addSeasons) = NULL
        addSeasons = c(addSeasons[idJan:12],
                       addSeasons[1:(idJan-1)])

        orderSeasons = get_Season[!duplicated(get_Season)]
        orderSeasons = orderSeasons[!is.na(orderSeasons)]
        nMonthOrderSeasons = sapply(orderSeasons, nchar)
        endSeasonsMonth = cumsum(nMonthOrderSeasons)
        startSeasonsMonth = endSeasonsMonth - nMonthOrderSeasons + 1
        idOrderJan = (which(unlist(strsplit(paste0(orderSeasons,
                                                   collapse=""),
                                            "")) == "D") + 1) %% 12
        startSeasonsMonth = (startSeasonsMonth - idOrderJan) %% 12 + 1
        
        SeasonsMonth = rep(startSeasonsMonth, nMonthOrderSeasons)
        SeasonsMonth = c(SeasonsMonth[idJan:12],
                         SeasonsMonth[1:(idJan-1)])

        tree("Sampling of the data", 2, verbose=verbose)

        samplePeriod$dRef =
            as.numeric(samplePeriod$refStart +
                       months(abs(samplePeriod$dt2add-1)) -
                       samplePeriod$refEnd)

        if (any(samplePeriod$dRef != 1)) {
        
            samplePeriod$dStart = as.numeric(substr(samplePeriod$spStart, 1, 2))
            samplePeriod$dEnd = as.numeric(substr(samplePeriod$spEnd, 1, 2))
            
            dataEX = dplyr::full_join(dataEX,
                                      samplePeriod[c("Code",
                                                     "dStart",
                                                     "dEnd")],
                                      by="Code")
            
            dataEX = dplyr::filter(dataEX,
                                   
            (refStart < refEnd)
            & dStart <= lubridate::day(Date)
            & lubridate::day(Date) <= dEnd
            
            |
            
            (refStart >= refEnd)
            & (lubridate::day(Date) <= dEnd
                | dStart <= lubridate::day(Date))
            
            )
            
            dataEX = dplyr::select(dataEX, -c(dStart,
                                              dEnd))
        }

        dataEX = dplyr::select(dataEX, -c(refStart,
                                          refEnd))

        if (!is.null(keep)) {
            dataEX_save = dplyr::select(dataEX, -c(spStart,
                                                   spEnd,
                                                   dt2add))
        }

        tree("Preparing date data for the extraction",
             end=TRUE, 2, verbose=verbose)

        tree("Computing of time indicators for each time serie",
             3, inEnd=2, verbose=verbose)

        
        sampleInfo =
            dplyr::summarise(dplyr::group_by(dataEX, Code),
                             minDate=min(Date),
                             minDateRef=
                                 as.Date(paste0(
                                     lubridate::year(minDate),
                                     "-",
                                     lubridate::month(minDate),
                                     "-01")),
                             spStart=spStart[1],
                             minSampleStart=
                                 lubridate::add_with_rollback(
                                                as.Date(paste0(
                                                    lubridate::year(minDate),
                                                    "-01-",
                                                    spStart[1])),
                                                months(lubridate::month(minDate)
                                                       - 1 - subSeasons[lubridate::month(minDate)])),
                             maxDate=max(Date),
                             spEnd=spEnd[1],
                             maxSampleEnd=
                                 lubridate::add_with_rollback(
                                                as.Date(paste0(
                                                    lubridate::year(maxDate),
                                                    "-01-",
                                                    spEnd[1])),
                                                months(lubridate::month(maxDate) + dt2add[1] + addSeasons[lubridate::month(maxDate)] - 1)),
                             maxSampleStart=
                                 lubridate::add_with_rollback(
                                                as.Date(paste0(
                                                    lubridate::year(maxDate),
                                                    "-01-",
                                                    spStart[1])),
                                                months(lubridate::month(maxDate)
                                                       - 1 - subSeasons[lubridate::month(maxDate)])),
                             .groups="drop")

        tree("Shifting the start of each year in order to speed extraction process", 3, inEnd=2, verbose=verbose)
        
        sampleInfo$Shift =
            lubridate::mday(sampleInfo$minSampleStart) - 1
        dataEX = dplyr::full_join(dataEX,
                                  sampleInfo[c("Code",
                                               "Shift")],
                                  by=c("Code"))
        
        dataEX$Date = dataEX$Date - dataEX$Shift


        if (timeStep == "season") {
            dataEX$Season = get_Season[lubridate::month(dataEX$Date)]

            dataEX$SeasonDate =
                lubridate::add_with_rollback(
                               dataEX$Date,
                               - months(subSeasons[lubridate::month(dataEX$Date)]))
            dataEX$YearSeason =
                paste0(lubridate::year(dataEX$SeasonDate),
                       "-",
                       get_Season[lubridate::month(dataEX$SeasonDate)])

            seasonInfo =
                dplyr::summarise(dplyr::group_by(dataEX,
                                                 Code,
                                                 YearSeason),
                                 Date=Date[!duplicated(YearSeason)],
                                 .groups="drop")
            seasonInfo =
                dplyr::summarise(
                           dplyr::group_by(seasonInfo,
                                           Code,
                                           Date=get_Season[lubridate::month(Date)]),
                           nYear=dplyr::n(),
                           .groups="drop")

            
        } else if (timeStep == "year-season") {
            dataEX$SeasonDate =
                lubridate::add_with_rollback(
                               dataEX$Date,
                               - months(subSeasons[lubridate::month(dataEX$Date)]))
            dataEX$YearSeason =
                paste0(lubridate::year(dataEX$SeasonDate),
                       "-",
                       get_Season[lubridate::month(dataEX$SeasonDate)])
            
            dataEX_tmp =
                dplyr::summarise(dplyr::group_by(dataEX,
                                                 Code,
                                                 YearSeason),
                                 Date_g=as.Date(paste0(
                                     lubridate::year(SeasonDate),
                                     "-",
                                     lubridate::month(SeasonDate),
                                     "-",
                                     spStart)),
                                 .groups="drop")

            dataEX_tmp = dplyr::distinct(dataEX_tmp)
            dataEX = dplyr::full_join(dataEX, dataEX_tmp,
                                      by=c("Code", "YearSeason"))
        } 
        
        sampleInfo$dNAstart =
            pmax(0, as.numeric(sampleInfo$minDate -
                              sampleInfo$minSampleStart))
        sampleInfo$dNAend =
            pmax(0, as.numeric(sampleInfo$maxSampleEnd -
                              sampleInfo$maxDate))

        sampleStartInfo =
            sampleInfo[c("Code", "minSampleStart", "dNAstart")]
        names(sampleStartInfo) = c("Code", "Date", "dNA")
        sampleEndInfo =
            sampleInfo[c("Code", "maxSampleStart", "dNAend")]
        names(sampleEndInfo) = c("Code", "Date", "dNA")
        

        sampleInfoCompress = dplyr::bind_rows(sampleStartInfo,
                                              sampleEndInfo)

        if (timeStep == "season") {
            sampleInfoCompress$Date =
                get_Season[lubridate::month(sampleInfoCompress$Date)]
            sampleInfoCompress =
                dplyr::summarise(dplyr::group_by(sampleInfoCompress,
                                                 Code, Date),
                                 dNA=sum(dNA),
                                 addYear=dplyr::n() - 1,
                                 .groups="drop")
        }

        dataEX = dplyr::full_join(dataEX,
                                  sampleInfo[c("Code",
                                               "minDateRef")],
                                  by=c("Code"))
        
        tree("Removing useless data", 3, end=TRUE, inEnd=2,
             verbose=verbose)
        dataEX = dplyr::select(dataEX, -c(Shift,
                                          spStart,
                                          spEnd,
                                          dt2add))
    }

    tree("Grouping data", 1, verbose=verbose)

    if (timeStep == "none") {
        dataEX = dplyr::group_by(dataEX,
                                 Code)
        colGroup = "Code"
        
    } else if (timeStep %in% c("year", "year-month", "month")) {
        if (timeStep == "year") {
            groupFormat = "%Y"
        } else if (timeStep == "year-month") {
            groupFormat = "%Y-%m"
        } else if (timeStep == "month") {
            groupFormat = "%m"
        }
        dataEX = dplyr::group_by(dataEX,
                                 Code,
                                 Date_g=format(Date,
                                               groupFormat))
        colGroup = c("Code", "Date_g")

    } else if (timeStep == "yearday") {
        dataEX = dplyr::group_by(dataEX,
                                 Code,
                                 Date_g=lubridate::yday(Date))
        colGroup = c("Code", "Date_g")
        
    } else {
        if (timeStep == "year-season") {
            dataEX = dplyr::group_by(dataEX,
                                     Code,
                                     Date_g,
                                     YearSeason)
            colGroup = c("Code", "Date_g", "YearSeason")
            
        } else if (timeStep == "season") {
            dataEX = dplyr::group_by(dataEX,
                                     Code,
                                     Date_g=Season)
            colGroup = c("Code", "Date_g")
        }
    }

    if (timeStep != "none") {
        if (!is.null(keep)) {
            dataEX_save$Date_g = dataEX$Date_g
        }
        nOK = dataEX$minDateRef <= dataEX$Date
        dataEX = dataEX[nOK,]
        if (!is.null(keep)) {
            dataEX_save = dataEX_save[nOK,]
        }
        if (any(isDate)) {
            minDateRef_save = dplyr::select(dplyr::ungroup(dataEX),
                                            c(Code,
                                              minDateRef))
            minDateRef_save = dplyr::distinct(minDateRef_save,
                                              .keep_all=TRUE)
        }
        dataEX = dplyr::select(dataEX, -minDateRef)
    }
    
    tree("Application of the function",
         1, verbose=verbose)

    if (!is.null(keep)) {
        if (timeStep == "none") {
            keepDate = list(Date="Date")
            colGroup = c("Code", "Date")
        } else if (timeStep == "yearday") {
            # keepDate = list(Date="Date")
            keepDate = NULL
        } else {
            keepDate = NULL
        }
    } else {
        keepDate = NULL
    }

    if (any(unlist(isColArgs))) {

        if (exists("dataEX_tmp")) {
            rm (dataEX_tmp)
        }

        for (i in 1:nfunct) {

            colArg = colArgs[[i]]
            otherArg = otherArgs[[i]]
            f = funct[[i]]
           
            dataEX$isNA =
                is.na(rowSums(dataEX[unlist(colArg)]))

            if (!exists("dataEX_tmp")) {
                dataEX_tmp =
                    dplyr::summarise(
                               dataEX,
                               !!!rlang::data_syms(keepDate),
                               !!paste0("ValueEX", i) :=
                                   f(!!!rlang::data_syms(colArg),
                                     !!!otherArg),
                               !!paste0("nNA", i) := sum(isNA),
                               n=dplyr::n(),
                               .groups='drop')
            } else {

                if (timeStep == "none") {
                    dataEX_tmp =
                        dplyr::full_join(
                                   dplyr::tibble(dataEX_tmp,
                                                 id=1:nrow(dataEX_tmp)),
                                   dplyr::tibble(dplyr::summarise(
                                                            dataEX,
                                                            !!!rlang::data_syms(keepDate),
                                                            !!paste0("ValueEX", i) :=
                                                                f(!!!rlang::data_syms(colArg),
                                                                  !!!otherArg),
                                                            !!paste0("nNA", i) :=
                                                                sum(isNA),
                                                            .groups='drop'),
                                                 id=1:nrow(dataEX_tmp)),
                                   by=c("id", colGroup))

                    dataEX_tmp = select(dataEX_tmp, -id)
                    
                        } else {
                            dataEX_tmp =
                        dplyr::full_join(
                                   dataEX_tmp,
                                   dplyr::summarise(
                                              dataEX,
                                              !!!rlang::data_syms(keepDate),
                                              !!paste0("ValueEX", i) :=
                                                  f(!!!rlang::data_syms(colArg),
                                                    !!!otherArg),
                                              !!paste0("nNA", i) :=
                                                  sum(isNA),
                                              .groups='drop'),
                                   by=colGroup)
                        }
            }
            nValue = nfunct
        }
        dataEX = dataEX_tmp
        rm (dataEX_tmp)

    } else {
        
        sumNA = function (X) {
            return (sum(is.na(X)))
        }

        dataEX = dplyr::summarise(
                            dataEX,
                            !!!rlang::data_syms(keepDate),
                            dplyr::across(.cols=unlist(colArgs),
                                          .fns=funct,
                                          !!!funct_args,
                                          .names=paste0("ValueEX{1:",
                                                        nValue, "}")),
                            dplyr::across(.cols=unlist(colArgs),
                                          .fns=sumNA,
                                          .names=paste0("nNA{1:",
                                                        nValue, "}")),
                            n=dplyr::n(),
                            .groups='drop')
    }

    tree("Cleaning extracted tibble", 1, verbose=verbose)

    if (timeStep != "none") {
        if (any(isDate)) {
            dataEX = dplyr::full_join(dataEX,
                                      minDateRef_save,
                                      by="Code")
            rm (minDateRef_save)
        }
                
        names(dataEX)[names(dataEX) == "Date_g"] = "Date"
    }

    infinite2NA = function (X) {
        if (tibble::is_tibble(X)) {
            X = dplyr::mutate(X, dplyr::across(.fns=infinite2NA))
        } else {
            X[is.infinite(X)] = NA
        }
        return (X)
    }
    
    dataEX = dplyr::mutate(dataEX,
                           dplyr::across(.cols=
                                             dplyr::starts_with(
                                                        paste0("ValueEX",
                                                               1:nValue)),
                                         .fns=infinite2NA),
                           .keep="all")
    
    if (timeStep == "year") {
        sampleInfoCompress$Date = format(sampleInfoCompress$Date,
                                         groupFormat)
        dataEX$nDay = 365.25
        
    } else if (timeStep == "year-month") {
        sampleInfoCompress$Date = format(sampleInfoCompress$Date,
                                         groupFormat)
        dataEX$nDay = 30.4375

    } else if (timeStep == "month") {
        sampleInfoCompress$Date = format(sampleInfoCompress$Date,
                                         groupFormat)
        dataEX = dplyr::full_join(dataEX,
                                  monthInfo,
                                  by=c("Code", "Date"))
        dataEX$nDay = 30.4375*dataEX$nYear
        dataEX = dplyr::select(dataEX, -nYear)

    } else if (timeStep == "year-season") {
        dataEX$nDay = nchar(gsub("^.*-", "", dataEX$YearSeason)) * 30.4375
        
    } else if (timeStep == "season") {
        dataEX = dplyr::full_join(dataEX,
                                  seasonInfo,
                                  by=c("Code", "Date"))

        dataEX$nDay = nchar(dataEX$Date) * 30.4375 *
            dataEX$nYear
        dataEX = dplyr::select(dataEX, -nYear)
    }

    if (timeStep %in% c("none", "yearday")) {
        compute_NApct = function (nNA, n) {
            NApct = round(nNA/n * 100, 1)
            return (NApct)
        }
        dataEX = dplyr::mutate(dataEX,
                               dplyr::across(.cols=
                                                 dplyr::starts_with(
                                                            paste0("nNA",
                                                                   1:nValue)),
                                             .fns=compute_NApct ,
                                             .names=paste0("NApct{1:",
                                                           nValue, "}"),
                                             n=n),
                               .keep="all")
        dataEX = dplyr::select(dataEX, -c(paste0("nNA",
                                                 1:nValue),
                                          n))
        
    } else {
        dataEX = dplyr::full_join(dataEX,
                                  sampleInfoCompress[c("Code",
                                                       "Date",
                                                       "dNA")],
                                  by=c("Code", "Date"))
        
        dataEX$dNA[is.na(dataEX$dNA)] = 0

        compute_NApct = function (nNA, dNA, nDay) {
            NApct = round((nNA + dNA)/nDay * 100, 1)
            return (NApct)
        }
        dataEX = dplyr::mutate(dataEX,
                               dplyr::across(.cols=
                                                 dplyr::starts_with(
                                                            paste0("nNA",
                                                                   1:nValue)),
                                             .fns=compute_NApct ,
                                             .names=paste0("NApct{1:",
                                                           nValue, "}"),
                                             dNA=dNA,
                                             nDay=nDay),
                               .keep="all")
        
        dataEX = dplyr::full_join(dataEX,
                                  samplePeriod[c("Code",
                                                 "spStart")],
                                  by="Code")

        if (!(timeStep %in% c("month", "year-season", "season", "yearday"))) {
            if (!is.null(keep)) {
                dataEX$Date_g = dataEX$Date
            }
            dataEX =
                dplyr::mutate(dplyr::group_by(dataEX, Code),
                              Date=as.Date(paste0(Date,
                                                  "-",
                                                  spStart[1])),
                              .keep="all")
        }
        dataEX = dplyr::select(dataEX, -c(paste0("nNA",
                                                 1:nValue),
                                          n,
                                          dNA,
                                          nDay,
                                          spStart))   
    }

    if (any(isDate)) {
        if (length(isDate) != nfunct) {
            isDate = rep(isDate[1], nfunct)
        }
        dataEX = convert_dateEX(dataEX, isDate, nValue=nValue,
                                isColArgs=isColArgs,
                                verbose=verbose)
    }

    if (!is.null(NApct_lim)) {
        dataEX = NA_filter(dataEX, timeStep=timeStep,
                           nValue=nValue,
                           NApct_lim=NApct_lim,
                           mod=NULL, verbose=verbose)
    }
    
    tree("Last cleaning", 1, end=TRUE, verbose=verbose)

    if (onlyDate4Season) {
        dataEX = dplyr::select(dataEX, -YearSeason)
    }

    if (!rmNApct & !(!is.null(keep)) & !compress & any(unlist(isColArgs))) {
        if (nfunct == 1) {
            dataEX = dplyr::rename(dataEX, NApct=NApct1)
            
        } else {
            for (i in 1:nfunct) {
                dataEX=
                    dplyr::rename(dataEX,
                                  !!paste0("NApct",
                                           "_",
                                           nameEX[i]) :=
                                      !!paste0("NApct", i))
            }
        }
    }
    if (rmNApct | !is.null(keep) | compress) {
        dataEX = dplyr::select(dataEX, -c(paste0("NApct",
                                                 1:nValue)))
    }

    if (!is.null(keep) & !(timeStep %in% c("month", "season"))) {
        if (!(timeStep %in% c("none", "yearday"))) {

            dataEX = dplyr::select(dataEX, -Date)
            dataEX = dplyr::left_join(dataEX_save,
                                      dataEX,
                                      by=colGroup)
            dataEX = dplyr::select(dataEX, -Date_g)

        } else if (timeStep %in% c("yearday")) {
            dataEX$Date = as.Date(dataEX$Date-1, origin=as.Date("1970-01-01"))
            
        } else {
            dataEX = dplyr::full_join(dataEX,
                                      dataEX_save,
                                      by=c("Code", "Date"))
        }
        
        dataEX = dplyr::select(dataEX, Code, dplyr::everything())
        dataEX = dplyr::relocate(dataEX, Date, .after=Code)
        rm (dataEX_save)
    }

    idCode = which(names(dataEX) == "Code")
    if (!(timeStep == "none" & is.null(keep))) {
        idDate = which(names(dataEX) == "Date")
    }
    
    idValue = which(grepl("ValueEX[[:digit:]]", names(dataEX)))

    if (timeStep == "yearday") {
        names_save[idDate_save] = "Yearday"
    } else if (timeStep == "month") {
        groupName = "Month"
        names_save[idDate_save] = groupName
    } else if (timeStep == "season") {
        groupName = "Season"
        names_save[idDate_save] = groupName
    }

    if (timeStep == "none" & is.null(keep)) {
        names(dataEX)[c(idCode, idValue)] =
            names_save[c(idCode_save, idValue_save)]
    } else {
        names(dataEX)[c(idCode, idDate, idValue)] =
            names_save[c(idCode_save, idDate_save, idValue_save)] 
    }

    if (!is.null(keep) & !compress) {
        test = grepl("Value[[:digit:]]", names(dataEX))
        if (any(test)) {
        
            idValue_keep = which(test)
            idIn =
                which(names_keepSave[idValue_keepSave] %in%
                      names(dataEX))

            if (length(idIn) > 0) {

                idRm = idValue_keep[idIn]
                
                dataEX = dataEX[-idRm] 
                
                idValue_keep = idValue_keep[-idIn]
                idValue_keepSave = idValue_keepSave[-idIn]
            }
            names(dataEX)[idValue_keep] =
                names_keepSave[idValue_keepSave]
        }
    }
    
    if (compress & timeStep %in% c("season", "month")) {
        if (timeStep == "season") {
            ref = "SEA"
        } else if (timeStep == "month") {
            ref = "MON"
        }

        valueName = names_save[idValue_save]
        codeName = names_save[idCode_save]

        Groups = levels(factor(dataEX[[groupName]]))
        nGroups = length(Groups)
        nValueName = length(valueName)

        for (i in 1:nGroups) {
            dataEX_filter = dataEX[dataEX[[groupName]] == Groups[i],]
            dataEX_filter =
                dplyr::select(dataEX_filter,
                              -dplyr::contains(groupName))

            for (j in 1:nValueName) {
                dataEX_filter =
                    dplyr::rename(dataEX_filter,
                                  !!gsub(ref, Groups[i],
                                         valueName[j]):= !!valueName[j])
            }

            if (!exists("dataEX_tmp")) {
                dataEX_tmp = dataEX_filter

            } else {
                dataEX_tmp =
                    dplyr::full_join(dataEX_tmp,
                                     dataEX_filter,
                                     by=codeName)
            }
        }
        dataEX = dataEX_tmp
        rm (dataEX_filter)
        rm (dataEX_tmp)
    }

    if (!is.null(keep)) {
        if (any(keep == "all")) {
            names_to_keep = names(dataEX)
        } else {
            names_to_keep =
                c(names_save[idCode_save],
                  names_save[idDate_save],
                  names_save[idValue_save][names_save[idValue_save] %in% keep])
            names_to_keep = names_to_keep[names_to_keep %in% names(dataEX)]
        }
        dataEX = dplyr::select(dataEX, names_to_keep)
    }

    dataEX = tidyr::unnest(dataEX,
                           dplyr::everything(),
                           names_sep="_")
    
    if (verbose) {
        print(dataEX)
    }
    
    return (dataEX)
}



fix_samplePeriod = function (samplePeriod, refDate,
                             sampleFormat, verbose=FALSE) {

    if (length(samplePeriod) == 1 | any(is.na(samplePeriod))) {
        if (length(samplePeriod) == 1) {
            
            tree("Only start of the sample period was given", 3,
                 inEnd=2,
                 verbose=verbose)
            samplePeriod =
                c(samplePeriod,
                  format(as.Date(paste0(refDate,
                                        '-',
                                        samplePeriod)) - 1,
                         sampleFormat))
            
        } else if (any(is.na(samplePeriod))) {
            idNA = which(is.na(samplePeriod))
            if (idNA == 1) {
                tree("Only end of the sample period was given", 3,
                     inEnd=2,
                     verbose=verbose)
                samplePeriod[1] =
                    format(as.Date(paste0(refDate,
                                          '-',
                                          samplePeriod[2])) + 1,
                           sampleFormat)
                
            } else if (idNA == 2) {
                tree("Only start of the sample period was given", 3,
                     inEnd=2,
                     verbose=verbose)
                samplePeriod[2] =
                    format(as.Date(paste0(refDate,
                                          '-',
                                          samplePeriod[1])) - 1,
                           sampleFormat)
            }
        }
    }
    return (samplePeriod)
}
    



convert_dataEX_hide = function (Value) {

    Month = Value / (365.25/12)        
    MonthNoNA = Month[!is.na(Month)]    
    fact = 2*pi/12
    monthMean_raw = CircStats::circ.mean(fact * MonthNoNA) / fact
    monthMean = (monthMean_raw + 12) %% 12

    upLim = round(monthMean + 6, 2)
    lowLim = round(monthMean - 6, 2)

    above = Month > upLim
    above[is.na(above)] = FALSE
    below = Month < lowLim
    below[is.na(below)] = FALSE
    
    Value[above] = Value[above] - 366
    Value[below] = Value[below] + 365
    return (Value)
}

#' @title convert_dateEX
#' @description Convert the index to date format for the extracted variables specified in the isDate argument. The date format is based on the date column of the input tibble and the function "convert_dataEX_hide" is used for the conversion.
#' @param dataEX A tibble containing a column named "Date" which corresponds to the index of each sample and one or several columns named "ValueEXx" (x being a number) that correspond to the extracted variables.
#' @param isDate A logical vector indicating whether the columns named "ValueEXx" should be converted to date format or not
#' @param nValue Number of columns named "ValueEXx"
#' @param isColArgs A logical vector indicating whether the columns named "ValueEXx" corresponds to column arguments of function used in the extraction process
#' @param verbose A logical, if TRUE output to the console will be provided
#' @return A tibble containing a column named "Date" which corresponds to the date of each sample and one or several columns named "ValueEXx" (x being a number) that correspond to the extracted variables.
#' @note documentation generated by chatGPT
#' @export
convert_dateEX = function(dataEX, isDate, nValue, isColArgs,
                          verbose=TRUE) {

    tree('Converting index to date', 1, verbose=verbose)
    
    dataEX$sampleStart = pmax(dataEX$Date, dataEX$minDateRef)
    dataEX$Shift = lubridate::yday(dataEX$sampleStart) - 1

    nfunct = length(isDate)
    
    if (any(unlist(isColArgs))) {

        for (i in 1:nfunct) {
            if (isDate[i]) {

                Value = paste0("ValueEX", i)
                dataEX[Value] = dataEX[Value] + dataEX$Shift

                dataEX = dplyr::mutate(dplyr::group_by(dataEX, Code),
                                       !!Value := convert_dataEX_hide(
                                           !!!rlang::data_syms(Value)),
                                       .keep="all")
            }
        }
        
        
    } else {
        dataEX[paste0("ValueEX", 1:nValue)] =
            dataEX[paste0("ValueEX", 1:nValue)] + dataEX$Shift
        
        dataEX = dplyr::mutate(dplyr::group_by(dataEX, Code),
                               dplyr::across(.cols=
                                                 dplyr::starts_with(
                                                            paste0("ValueEX",
                                                                   1:nValue)),
                                             .fns=convert_dataEX_hide),
                               .keep="all")       
        
    }
    
    dataEX = dplyr::select(dataEX, -c(minDateRef,
                                      sampleStart,
                                      Shift))
    return (dataEX)
}


## 3. NA FILTER AFTER EXTRACTION _____________________________________
#' @title NA filter
#' @description Filters the rows with a NA percentage above the threshold given in parameter.
#' @param dataEX Data after extraction that should be filtered.
#' @param timeStep Character string indicating the time step of the extraction, could be 'none' if the time step doesn't matter, 'year' or 'year-month'.
#' @param nValue Number of values extracted.
#' @param NApct_lim Percentage limit of NA above which rows will be removed. Default is 1.
#' @param mod A list of modification to store comments of filtering applied.
#' @param verbose Logical, when true prints message indicating the removal of data due to high NA percentage
#' @return dataEX filtered by the percentage of NA allowed in input.
#' @importFrom lubridate is.Date
#' @note documentation generated by chatGPT
#' @export
NA_filter = function (dataEX, timeStep, nValue, NApct_lim=1,
                      mod=NULL, verbose=TRUE) {

    tree(paste0('Removing data if NA percentage is strictly above ',
                NApct_lim, " %"), 1, verbose=verbose)

    NApct2filter = function (X, NApct_lim) {
        filter = X > NApct_lim
        filter[is.na(filter)] = FALSE
        return (filter)
    }
    
    dataEX = dplyr::mutate(dataEX,
                           dplyr::across(.cols=
                                             dplyr::starts_with(
                                                        paste0("NApct",
                                                               1:nValue)),
                                         .fns=NApct2filter,
                                         NApct_lim=NApct_lim,
                                         .names=paste0("filter{1:",
                                                       nValue, "}")),
                           .keep="all")
    
    filter2NA = function (X, filter) {
        X[filter] = NA
        return (X)
    }
    
    dataEX[paste0("ValueEX", 1:nValue)] =
        Map(filter2NA,
            X=dataEX[paste0("ValueEX", 1:nValue)],
            filter=dataEX[paste0("filter", 1:nValue)])

    # codeFilter = dataEX$Code[dataEX$filter]
    # codeFilter = codeFilter[!duplicated(codeFilter)]
    # if (timeStep == "none") {
    #     dateFilter = ""
    # } else {
    #     if (lubridate::is.Date(dataEX$Date[1])) {
    #         dateFilter = format(dataEX$Date[dataEX$filter], "%Y")
    #     } else {
    #         dateFilter = dataEX$Date[dataEX$filter]
    #     }
    # }
    # Nmod = length(codeFilter)

    # if (!is.null(mod) & !identical(codeFilter, character(0))) {
    #     for (i in 1:Nmod) {
    #         mod =
    #             add_mod(mod, codeFilter[i],
    #                     type='Filtering of NA percentage after EXtraction',
    #                     fun_name='NA assignment',
    #                     comment=paste0('Removal of year ', dateFilter[i]))
    #     }
    # }

    dataEX = dplyr::select(dataEX, -paste0("filter", 1:nValue))

    if (!is.null(mod)) {
        res = list(data=dataEX, mod=mod)
        return (res)
    } else {
        return (dataEX)
    }
}



## 2. MANAGES MISSING DATA ___________________________________________
### 2.1. Long missing period over several years ______________________
missing_year_hide = function (Value, Date, NAyear_lim) {

    DateNA = Date[is.na(Value)]
    dDateNA = diff(DateNA)
    if (length(dDateNA) == 0) {
        return (Value)
    }
    dDateNA = c(10, dDateNA)

    idJump = which(dDateNA != 1)
    NJump = length(idJump)

    if (NJump > 0) {
    
        for (i in 1:NJump) {
            idStartNA = idJump[i]
            
            if (i < NJump) {
                idEndNA = idJump[i+1] - 1
            } else {
                idEndNA = length(DateNA)
            }

            StartNA = DateNA[idStartNA]
            EndNA = DateNA[idEndNA]
            
            duration = as.numeric((EndNA - StartNA)/365.25)
            
            if (duration >= NAyear_lim) {
                
                Start = min(Date, na.rm=TRUE)
                End = max(Date, na.rm=TRUE)
                
                Before = StartNA - Start
                After = End - EndNA
                if (Before < After) {
                    Value[Date <= StartNA] = NA
                    start = Start
                    end = StartNA
                } else {
                    Value[Date >= EndNA] = NA
                    start = EndNA
                    end = End
                }
            }
        }
    }
    return (Value)
}

#' @title Missing year
#' @description This function will check for any continuous missing period longer than a specified threshold of years in each time series and assign them as missing values.
#' @param data A data.frame containing at least a date column, a numeric column and a column indicating a name of time series, in order to identify them.
#' @param nValue number of numeric column
#' @param NAyear_lim threshold of year duration for missing period.
#' @param mod An object of class modification, it will store all modification made to the data
#' @param verbose logical for print messages
#' @return return the dataframe with identified missing period as NA
#' @note documentation generated by chatGPT
#' @export
#' @note documentation generated by chatGPT
#' @export
missing_year = function (data, nValue, NAyear_lim=10,
                         mod=NULL, verbose=TRUE) {

    tree("Missing year", 1, verbose=verbose)
    tree(paste0('Checking missing continuous periods longer than ',
                NAyear_lim, ' years'), 2, is.null(mod), verbose=verbose)

    dataMOD = dplyr::mutate(
                         dplyr::group_by(data, Code),
                         dplyr::across(paste0("Value",
                                              1:nValue),
                                       missing_year_hide,
                                       Date=Date,
                                       NAyear_lim=NAyear_lim),
                         .keep="all")

    # if (!is.null(mod)) {
    #     tree('Wrinting modifications', 2, !is.null(mod),
    #          verbose=verbose)        
    #     isCorr = is.na(df_Value$Value) != is.na(data$Value)
    #     CodeCorr = df_Value$Code[isCorr]
    #     CodeCorr = CodeCorr[!duplicated(CodeCorr)]

    #     for (code in CodeCorr) {

    #         df_Value_code = df_Value[df_Value$Code == code,]
    #         data_code = data[data$Code == code,]

    #         isCorr_code = is.na(df_Value_code$Value) != is.na(data_code$Value)

    #         DateCorr_code = df_Value_code$Date[isCorr_code]

    #         start = min(DateCorr_code)
    #         end = max(DateCorr_code)
            
    #         mod =
    #             add_mod(mod, code,
    #                     type='Missing data management',
    #                     fun_name='NA assignment',
    #                     comment=paste('From ', start,
    #                                   ' of measurements',
    #                                   ' to ', end, sep=''))
    #     }
    # }

    # replace2NA = function (X) {
    #     X = replace(X, list=which(is.na(X)), value=NA)
    #     return (X)
    # }
    # data = dplyr::mutate(data,
    #                      dplyr::across(unlist(colArgs),
    #                                    replace2NA))


    data[paste0("Value", 1:nValue)] = dataMOD[paste0("Value", 1:nValue)]

    if (!is.null(mod)) {
        res = list(data=data, mod=mod)
        return (res)
    } else {
        return (data)
    }
}



