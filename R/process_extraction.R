# Copyright 2021-2023 Louis Héraut (louis.heraut@inrae.fr)*1,
#                     Éric Sauquet (eric.sauquet@inrae.fr)*1,
#           2023 Jean-Philippe Vidal (jean-philippe.vidal@inrae.fr)*1
#
# *1   INRAE, France
#
# This file is part of EXstat R package.
#
# EXstat R package is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# EXstat R package is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with EXstat R package.
# If not, see <https://www.gnu.org/licenses/>.


#' @title process_extraction
#' @description This process extract a variable from time series (for
#' example the yearly mean of time series). Extraction can be yearly,
#' monthly or realised each month of every year and sampled
#' differently along years or months.
#' @param data Input data format is a tibble of at least a column of
#' date, a column of numeric value and a character column for names of
#' time series in order to identify them. Thus it is possible to have
#' a tibble with multiple time series which can be grouped by their
#' names.
#' @param funct The function (for example `mean`) that you want to
#' use. Arguments of the chosen function can be passed to this
#' extraction process and the function can be previously defined.
#' @param period A vector of two date to restrict the period of
#' analysis. Imposed date format is "YYYY-mm-dd". As an example it can
#' be c("1950-01-01", "2020-12-31") to select data from the 1st
#' january of 1950 to the end of december of 2020. The default option
#' is period=NULL which considers all available data.
#' @param isDate logical, if TRUE, function will assume that Date is a
#' date and not a numeric value.
#' @param NApct_lim numeric, maximum percentage of missing values in the time serie allowed.
#' @param NAyear_lim numeric, maximum number of missing years allowed.
#' @param Seasons vector of 4 characters, the default season set is "DJF", "MAM", "JJA", "SON"
#' @param onlyDate4Season logical, if TRUE, seasons computation will be based only on date.
#' @param nameEX character, name of the extracted variable
#' @param keep a character vector of column names to keep in the output dataframe.
#' @param compress logical. Should the function return a tibble or a compressed tibble?
#' @param rmNApct logical. Should rows with a high percentage of missing values be removed?
#' @param ... Arguments needed for the function provided through \code{funct}.
#' @examples
#' # Date
#' Start = as.Date("1972-01-01")
#' End = as.Date("2020-12-31")
#' Date = seq.Date(Start, End, by="day")
#' 
#' # Value to analyse
#' set.seed(100)
#' X = seq(1, length(Date))/1e4 + runif(length(Date), -100, 100)
#' X[as.Date("2000-03-01") <= Date & Date <= as.Date("2000-09-30")] = NA
#'
#' # Creation of tibble
#' data = dplyr::tibble(Date=Date, ID="serie A", X=X)
#'
#' # Extraction
#' dataEX = process_extraction(data=data,
#'                             samplePeriod=c("05-01",
#'                                            "11-30"),
#'                             funct=max,
#'                             na.rm=TRUE,
#'                             period=c(as.Date("1990-01-01"),
#'                                      as.Date("2020-12-31")),
#'                             timeStep="year")
#' dataEX
#' @importFrom rlang .data
#' @note documentation generated by chatGPT
#' @export
process_extraction = function(data,
                              funct=max,
                              funct_args=list(),
                              timeStep="year",
                              samplePeriod=NULL,
                              period=NULL,
                              isDate=FALSE,
                              NApct_lim=NULL,
                              NAyear_lim=NULL,
                              Seasons=c("DJF", "MAM", "JJA", "SON"),
                              onlyDate4Season=FALSE,
                              nameEX="X",
                              suffix=NULL,
                              keep=NULL,
                              compress=FALSE,
                              expand=FALSE,
                              rmNApct=FALSE,
                              verbose=FALSE, 
                              ...) {

    tree("EXTRACTION PROCESS", 0, verbose=verbose)

    if (is.character(period)) {
        period = as.Date(period)
    }

    ID_colnames = names(dplyr::select(data, dplyr::where(is.character)))
    if (length(ID_colnames) > 1) {
        data = tidyr::unite(data, "ID", dplyr:: where(is.character),
                            sep="_")
    }
    
    names_save = names(data)
    idValue_save = c()
    for (id in 1:ncol(data)) {
        x = data[[id]]

        if (is.character(x)) {
            idCode_save = id
        } else if (lubridate::is.Date(x)) {
            idDate_save = id
        } else if (is.numeric(x)) {
            idValue_save = c(idValue_save, id)
        }
    }

    if (!exists("idDate_save")) {
        idDate_save = NULL
    }

    idValue_keepSave = idValue_save
    names_keepSave = names_save
    
    nValue = length(idValue_save)
    colName = paste0("Value", 1:nValue)

    if (is.function(funct)){
        funct = list(funct)
    }
    if (!is.list(funct_args[[1]])) {
        funct_args = list(funct_args)
    }

    nfunct = length(funct)
    
    if (!is.null(suffix)) {
        where_no_suffix = c()
        for (i in 1:nfunct) {
            arg = funct_args[[i]]            
            arg_suffix =
                unlist(lapply(unlist(arg),
                              paste0, suffix))

            # print(arg_suffix)
            # print(names_save)
            # print("")
            
            where_no_suffix = c(where_no_suffix,
                                !any(arg_suffix %in%
                                    names_save))
        }
    } else {
        where_no_suffix = rep(TRUE, nfunct)
    }


    # print("")
    # print("suffix")
    # print(suffix)

    # print("nfunct")
    # print(nfunct)
    # print("where_no_suffix")
    # print(where_no_suffix)

    
    if (!is.null(suffix)) {
        nfunct_tmp = length(funct)
        nsuffix_tmp = length(suffix)
        if (nsuffix_tmp > 1) {
            funct_args = rep(funct_args, nsuffix_tmp)
            funct = rep(funct, nsuffix_tmp)
            isDate = rep(isDate, nsuffix_tmp)
            where_no_suffix = rep(where_no_suffix,
                                  nsuffix_tmp)
        }
        suffix = rep(suffix, each=nfunct_tmp)

        funct2keep =
            !duplicated(as.numeric(where_no_suffix),
                        incomparables=0)
        funct = funct[funct2keep]
        funct_args = funct_args[funct2keep]
        isDate = isDate[funct2keep]
        suffix = suffix[funct2keep]
        where_no_suffix = where_no_suffix[funct2keep]
    }



    get_colarg = function (arg_match, colName) {
        colName[arg_match]
    }
    
    colArgs_save = list()
    colArgs = list()
    otherArgs = list()
    colArgs_order = list()
    
    nfunct = length(funct)
    
    for (i in 1:nfunct) {
        arg = funct_args[[i]]

        isDateColArgs = any(arg %in% names_save[idDate_save])
        if (isDateColArgs) {
            names_save = c(names_save, "ValueDate")
            idValue_save = c(idValue_save, max(idValue_save)+1)
            colName = c(colName, paste0("Value",
                                        length(idValue_save)))
            data["ValueDate"] = data[idDate_save]
            funct_args[[i]][arg %in% names_save[idDate_save]] =
                "ValueDate"
            arg = funct_args[[i]]
        }
        
        if (!is.null(suffix) & !where_no_suffix[i]) {
            arg_match = lapply(lapply(arg, paste0, suffix[i]),
                               match,
                               table=names_save[idValue_save])
        } else {
            arg_match = lapply(arg,
                               match,
                               table=names_save[idValue_save])

            if (!is.null(suffix)) {
                suffix[i] = ""
            }
        }
        
        okNA = sapply(lapply(arg_match, is.na), any)
        
        colarg = lapply(arg_match[!okNA], get_colarg, colName)
        otherarg = arg[okNA]

        colArgs = append(colArgs,
                         list(colarg))
        
        otherArgs = append(otherArgs,
                           list(otherarg))
    }

    if (length(colArgs) == 0) {
        stop (paste0("Are the given parameters that refer to column names spelled correctly ? ",
                     funct_args, " is given but only names in ",
                     paste0(names_keepSave[idValue_save], collapse=", "),
                     " are possible."))
    }


    
    # print(data)
    # print("colArgs")
    # print(colArgs)
    # print("otherArgs")
    # print(otherArgs)

    # print("suffix")
    # print(suffix)
    
    # data = data

    
    if (!is.null(idDate_save)) {
        names(data)[c(idCode_save, idDate_save, idValue_save)] =
            c("Code", "Date", unlist(colName))
    } else {
        names(data)[c(idCode_save, idValue_save)] =
            c("Code", unlist(colName))
    }
    
    if (!is.null(names(funct)) & all(names(funct) != "")) {
        nameEX = names(funct)
    } else {
        if (length(nameEX) != nfunct) {
            nameEX = paste0(nameEX[1], 1:nfunct)
        }
    }

    if (!is.null(suffix)) {
        nameEX = paste0(nameEX, suffix)
    }

    # print(nfunct)
    # print("nameEX")
    # print(nameEX)
    

    if (nValue > nfunct) {
        names_save = names_save[-c(idValue_save[(nfunct+1):nValue])]
        idValue_save = idValue_save[1:nfunct]
        
    } else if (nValue < nfunct) {
        idValue_save = idValue_save[1:nfunct]
        isNA = is.na(idValue_save)
        nNA = sum(isNA)
        maxId = max(idValue_save, na.rm=TRUE)
        idValue_save[isNA] = (maxId + 1):(maxId + nNA)
    }
    
    names_save[idValue_save[1:nfunct]] = nameEX

    if (!is.null(samplePeriod) & dplyr::is.tbl(samplePeriod)) {
        if ("args" %in% names(samplePeriod)) {
            apply_name = function (X, table, name) {
                Xres = name[match(X, table)]
                Xres[is.na(Xres)] = X[is.na(Xres)]
                names(Xres) = names(X)
                return (Xres)
            }
            samplePeriod$args = lapply(samplePeriod$args,
                                       apply_name,
                                       table=names_keepSave,
                                       name=names(data))
            
        } else {
            samplePeriop$args = NA
        }
    }

    if (!is.null(NAyear_lim) & !is.null(idDate_save)) {
        data = missing_year(data, nValue, NAyear_lim,
                            verbose=verbose)
    }

    tree("Period", 1, verbose=verbose)
    if (is.null(period) | is.null(idDate_save)) {
        tree("Selecting all the data",
             2, TRUE, verbose=verbose)
    } else {
        tree(paste0("Selecting data between ",
                    format(period[1], "%d %b %Y"),
                    " and ",
                    format(period[2], "%d %b %Y")),
             2, TRUE, verbose=verbose)
        data = dplyr::filter(data, period[1] <= Date & Date <= period[2])
    }

    if (timeStep %in% c("year", "none")) {
        refDate = "1972"
        sampleFormat = "%m-%d"

    } else if (timeStep %in% c("yearday",
                               "month", "year-month",
                               "season", "year-season")) {
        refDate = "1972-01"
        sampleFormat = "%d"
    }

    Code = names(table(data$Code))

    tree("Sample period", 1, verbose=verbose)

    if (is.null(samplePeriod) | all(is.na(samplePeriod))) {
        tree("Default sample period used", 2,
             verbose=verbose)
        if (timeStep %in% c("year", "none")) {
            samplePeriod = "01-01"
        } else if (timeStep %in% c("yearday",
                                   "month", "year-month",
                                   "season", "year-season")) {
            samplePeriod = "01"
        }
    }

    if (dplyr::is.tbl(samplePeriod)) {

        if (nrow(samplePeriod) == 1) {
            samplePeriod = dplyr::tibble(Code=Code,
                                         samplePeriod)
            
        } else {
            idCode = which((names(samplePeriod) %in% names_save))        
            names(samplePeriod)[idCode] = c("Code")
            samplePeriod = samplePeriod[samplePeriod$Code %in% Code,]
        }

        tree("Fixing sample period for each time series", 2,
             verbose=verbose)

        samplePeriod =
            dplyr::summarise(
                       dplyr::group_by(samplePeriod,
                                       Code),
                       sp=list(
                           fix_samplePeriod(
                               sp,
                               data_code=
                                   dplyr::rename_with(
                                              data,
                                              ~names_keepSave)[
                                              data$Code ==
                                              dplyr::cur_group()$Code,],
                               args=args,
                               suffix=suffix[1],
                               refDate=refDate,
                               sampleFormat=sampleFormat,
                               verbose=FALSE)),
                       .groups="drop")
        
    } else {

        d = try(as.Date(paste0(refDate, "-", samplePeriod),
                        format="%Y-%m-%d"))        
        if ("try-error" %in% class(d) || any(is.na(d))) {
            if (timeStep %in% c("year", "none")) {
                stop ("'samplePeriod' given is not in the right format. You should use two valid number to select a month and a day of the year separated by a '-' for the starting (and/or ending) of the sample period (i.e. '02-10' for the 10th of february). See documentation.")
            } else {
                stop ("'samplePeriod' given is not in the right format. You should use one valid number to select a day of a month for the starting (and/or ending) of the sample period (i.e. '10' for the 10th day of the month). See documentation.")
            }
        }

        if (is.character(samplePeriod)) {
            tree("Fixing sample period", 2, end=TRUE,
                 verbose=verbose)
            samplePeriod = fix_samplePeriod(samplePeriod,
                                            refDate=refDate,
                                            sampleFormat=sampleFormat,
                                            verbose=verbose)
            
        } else {
            tree("Sample period fully given", 2, end=TRUE,
                 verbose=verbose)
        }
        samplePeriod = dplyr::tibble(Code=Code,
                                     sp=rep(list(samplePeriod),
                                            length(Code)))
    }

    samplePeriod =
        dplyr::summarise(dplyr::group_by(samplePeriod,
                                         Code),
                         sp=list(fix_samplePeriod_FUCKING29FEB(
                             sp,
                             sampleFormat=sampleFormat)),
                         .groups="drop")

    samplePeriod$spStart = sapply(samplePeriod$sp, "[[", 1)
    samplePeriod$spEnd = sapply(samplePeriod$sp, "[[", 2)
    
    samplePeriod$refStart = as.Date(paste0(refDate,
                                           '-',
                                           samplePeriod$spStart))
    samplePeriod$refEnd = as.Date(paste0(refDate,
                                         '-',
                                         samplePeriod$spEnd))

    if (length(samplePeriod$spStart[!duplicated(samplePeriod$spStart)]) == 1 & length(samplePeriod$spEnd[!duplicated(samplePeriod$spEnd)]) == 1) {
        
        tree("Every time series have the same sample period", 3, inEnd=2, verbose=verbose)
        tree(paste0("All : ", samplePeriod$spStart[1],
                    " / ", samplePeriod$spEnd[1]),
             3, end=TRUE, inEnd=2, verbose=verbose)
        
    } else {
        toTree = paste0(samplePeriod$Code, " : ",
                        samplePeriod$spStart,
                        " / ",
                        samplePeriod$spEnd)
        
        nToTree = length(toTree)
        for (t in 1:nToTree) {
            if (t == nToTree) {
                end = TRUE
            } else {
                end = FALSE
            }
            tree(toTree[t], 3, end=end, inEnd=2, verbose=verbose)
        }
    }

    samplePeriod$dt2add = 0
    samplePeriod$dt2add[samplePeriod$refStart >= samplePeriod$refEnd] = 1

    data = dplyr::full_join(data,
                            samplePeriod[c("Code",
                                           "spStart",
                                           "spEnd",
                                           "refStart",
                                           "refEnd",
                                           "dt2add")],
                            by="Code")
    
    if (timeStep == "none") {

        tree("None extraction", 1, verbose=verbose)
        tree("Sampling of the data", 2, verbose=verbose)
        
        samplePeriod$dRef =
            as.numeric(samplePeriod$refStart +
                       lubridate::years(abs(samplePeriod$dt2add-1)) -
                       samplePeriod$refEnd)

        if (any(samplePeriod$dRef != 1)) {
            
            samplePeriod$mStart =
                as.numeric(substr(samplePeriod$spStart, 1, 2))
            samplePeriod$dStart =
                as.numeric(substr(samplePeriod$spStart, 4, 5))
            samplePeriod$mEnd =
                as.numeric(substr(samplePeriod$spEnd, 1, 2))
            samplePeriod$dEnd =
                as.numeric(substr(samplePeriod$spEnd, 4, 5))
            
            data = dplyr::full_join(data,
                                    samplePeriod[c("Code",
                                                   "mStart",
                                                   "dStart",
                                                   "mEnd",
                                                   "dEnd")],
                                    by="Code")
            
            data = dplyr::filter(data,
                                 
            (refStart < refEnd)
            & (mStart < lubridate::month(Date)
                | (mStart == lubridate::month(Date)
                    & dStart <= lubridate::day(Date)))
            & (lubridate::month(Date) < mEnd
                | (lubridate::month(Date) == mEnd
                    & lubridate::day(Date) <= dEnd))
            
            |
            
            (refStart >= refEnd)
            & ((lubridate::month(Date) < mEnd
                | (lubridate::month(Date) == mEnd
                    & lubridate::day(Date) <= dEnd))
                | (mStart < lubridate::month(Date)
                    | (mStart == lubridate::month(Date)
                        & dStart <= lubridate::day(Date))))
            
            )
            
            data = dplyr::select(data, -c(mStart,
                                          dStart,
                                          mEnd,
                                          dEnd))
        }
        
        data = dplyr::select(data, -c(spStart,
                                      spEnd,
                                      refStart,
                                      refEnd,
                                      dt2add))

        # if (!is.null(keep)) {
        #     data_save = dplyr::select(data, -c(spStart,
        #                                        spEnd,
        #                                        dt2add))
        # }

    } else if (timeStep == "year") {
        tree("Yearly extraction", 1, verbose=verbose)
        tree("Sampling of the data", 2, verbose=verbose)

        samplePeriod$dRef =
            as.numeric(samplePeriod$refStart +
                       lubridate::years(abs(samplePeriod$dt2add-1)) -
                       samplePeriod$refEnd)

        if (any(samplePeriod$dRef != 1)) {
            
            samplePeriod$mStart =
                as.numeric(substr(samplePeriod$spStart, 1, 2))
            samplePeriod$dStart =
                as.numeric(substr(samplePeriod$spStart, 4, 5))
            samplePeriod$mEnd =
                as.numeric(substr(samplePeriod$spEnd, 1, 2))
            samplePeriod$dEnd =
                as.numeric(substr(samplePeriod$spEnd, 4, 5))
            
            data = dplyr::full_join(data,
                                    samplePeriod[c("Code",
                                                   "mStart",
                                                   "dStart",
                                                   "mEnd",
                                                   "dEnd")],
                                    by="Code")
            
            data = dplyr::filter(data,
                                 
            (refStart < refEnd)
            & (mStart < lubridate::month(Date)
                | (mStart == lubridate::month(Date)
                    & dStart <= lubridate::day(Date)))
            & (lubridate::month(Date) < mEnd
                | (lubridate::month(Date) == mEnd
                    & lubridate::day(Date) <= dEnd))
            
            |
            
            (refStart >= refEnd)
            & ((lubridate::month(Date) < mEnd
                | (lubridate::month(Date) == mEnd
                    & lubridate::day(Date) <= dEnd))
                | (mStart < lubridate::month(Date)
                    | (mStart == lubridate::month(Date)
                        & dStart <= lubridate::day(Date))))
            
            )
            
            data = dplyr::select(data, -c(mStart,
                                          dStart,
                                          mEnd,
                                          dEnd))
        }
        
        data = dplyr::select(data, -c(refStart,
                                      refEnd))

        # if (!is.null(keep)) {
        #     data_save = dplyr::select(data, -c(spStart,
        #                                        spEnd,
        #                                        dt2add))
        # }

        tree("Preparing date data for the extraction",
             end=TRUE, 2, verbose=verbose)
        tree("Computing of time indicators for each time serie",
             3, inEnd=2, verbose=verbose)

        sampleInfo =
            dplyr::summarise(dplyr::group_by(data, Code),
                             minDate=min(Date),
                             .groups="drop")
        
        sampleInfo =
            dplyr::summarise(dplyr::group_by(data, Code),
                             minDate=min(Date),
                             minDateRef=
                                 as.Date(paste0(
                                     lubridate::year(minDate),
                                     "-01-01")),
                             spStart=spStart[1],
                             minSampleStart=
                                 as.Date(paste0(
                                     lubridate::year(minDate),
                                     "-",
                                     spStart[1])),
                             maxDate=max(Date),
                             spEnd=spEnd[1],
                             maxSampleEnd=
                                 lubridate::add_with_rollback(
                                                as.Date(paste0(
                                                    lubridate::year(maxDate),
                                                    "-",
                                                    spEnd[1])),
                                                lubridate::years(dt2add[1])),
                             .groups="drop")
        
        tree("Shifting the start of each year in order to speed extraction process", 3, inEnd=2, verbose=verbose)

        sampleInfo$isAfterFeb =
            as.Date(paste0(refDate, "-", sampleInfo$spStart)) >
            as.Date(paste0(refDate, "-02-28"))
        
        sampleInfo$Shift =
            lubridate::yday(as.Date(paste0(refDate,
                                           "-",
                                           sampleInfo$spStart))) - 1

        sampleInfo$Shift[sampleInfo$isAfterFeb] =
            sampleInfo$Shift[sampleInfo$isAfterFeb] - 1

        data = dplyr::full_join(data, sampleInfo[c("Code",
                                                   "Shift")],
                                by=c("Code"))

        data$Year = lubridate::year(data$Date)
        Add4LeapYear =
            dplyr::summarise(
                       dplyr::group_by(data,
                                       Code,
                                       spStart,
                                       Year),
                       isLeapYear=check_leapYear(Year[1]),
                       .groups="drop")


        Add4LeapYear = dplyr::full_join(Add4LeapYear,
                                        sampleInfo[c("Code",
                                                     "isAfterFeb")],
                                        by=c("Code"))

        Add4LeapYear$Add2Shift =
            as.numeric(Add4LeapYear$isAfterFeb &
                       Add4LeapYear$isLeapYear)

        data = dplyr::full_join(data,
                                Add4LeapYear[c("Code",
                                               "Year",
                                               "Add2Shift")],
                                by=c("Code", "Year"))

        data$Shift = data$Shift + data$Add2Shift
        data$Date = data$Date - data$Shift

        sampleInfo$dNAstart =
            pmax(0, as.numeric(sampleInfo$minDate -
                               sampleInfo$minSampleStart))
        sampleInfo$dNAend =
            pmax(0, as.numeric(sampleInfo$maxSampleEnd -
                               sampleInfo$maxDate))

        sampleStartInfo =
            sampleInfo[c("Code", "minDate", "dNAstart")]
        names(sampleStartInfo) = c("Code", "Date", "dNA")
        sampleEndInfo =
            sampleInfo[c("Code", "maxDate", "dNAend")]
        names(sampleEndInfo) = c("Code", "Date", "dNA")

        sampleInfoCompress = dplyr::bind_rows(sampleStartInfo,
                                              sampleEndInfo)

        sampleInfoCompress$Date =
            as.Date(paste0(lubridate::year(sampleInfoCompress$Date),
                           "-01-01"))

        data = dplyr::full_join(data,
                                sampleInfo[c("Code",
                                             "minDateRef",
                                             "minDate")],
                                by=c("Code"))

        tree("Removing useless data", 3, end=TRUE, inEnd=2,
             verbose=verbose)

        data = dplyr::select(data, -c(Year,
                                      Shift,
                                      Add2Shift,
                                      spStart,
                                      spEnd,
                                      dt2add))
        
    } else if (timeStep == "yearday") {
        
        tree("Yearday extraction", 1, verbose=verbose)
        tree("Sampling of the data", 2, verbose=verbose)

        samplePeriod$dRef =
            as.numeric(samplePeriod$refStart +
                       months(abs(samplePeriod$dt2add-1)) -
                       samplePeriod$refEnd)

        if (any(samplePeriod$dRef != 1)) {
            
            samplePeriod$dStart = as.numeric(substr(samplePeriod$spStart, 1, 2))
            samplePeriod$dEnd = as.numeric(substr(samplePeriod$spEnd, 1, 2))
            
            data = dplyr::full_join(data,
                                    samplePeriod[c("Code",
                                                   "dStart",
                                                   "dEnd")],
                                    by="Code")
            
            data = dplyr::filter(data,
                                 
            (refStart < refEnd)
            & dStart <= lubridate::day(Date)
            & lubridate::day(Date) <= dEnd
            
            |
            
            (refStart >= refEnd)
            & (lubridate::day(Date) <= dEnd
                | dStart <= lubridate::day(Date))
            
            )
            
            data = dplyr::select(data, -c(dStart,
                                          dEnd))
        }

        data = dplyr::select(data, -c(refStart,
                                      refEnd))

        # if (!is.null(keep)) {
        #     data_save = dplyr::select(data, -c(spStart,
        #                                        spEnd,
        #                                        dt2add))
        # }

        tree("Preparing date data for the extraction",
             end=TRUE, 2, verbose=verbose)
        tree("Computing of time indicators for each time serie",
             3, inEnd=2, verbose=verbose)

        sampleInfo =
            dplyr::summarise(dplyr::group_by(data, Code),
                             minDate=min(Date),
                             minDateRef=
                                 as.Date(paste0(
                                     lubridate::year(minDate),
                                     "-",
                                     lubridate::month(minDate),
                                     "-01")),
                             spStart=spStart[1],
                             maxDate=max(Date),
                             spEnd=spEnd[1],
                             .groups="drop")
        
        tree("Shifting the start of each year in order to speed extraction process", 3, inEnd=2, verbose=verbose)

        sampleInfo$isAfterFeb =
            as.Date(paste0(refDate, "-", sampleInfo$spStart)) >
            as.Date(paste0(refDate, "-02-28"))
        
        sampleInfo$Shift =
            lubridate::yday(as.Date(paste0(refDate,
                                           "-",
                                           sampleInfo$spStart))) - 1

        sampleInfo$Shift[sampleInfo$isAfterFeb] =
            sampleInfo$Shift[sampleInfo$isAfterFeb] - 1

        data = dplyr::full_join(data, sampleInfo[c("Code",
                                                   "Shift")],
                                by=c("Code"))

        data$Year = lubridate::year(data$Date)
        Add4LeapYear =
            dplyr::summarise(
                       dplyr::group_by(data,
                                       Code,
                                       spStart,
                                       Year),
                       isLeapYear=check_leapYear(Year[1]),
                       .groups="drop")


        Add4LeapYear = dplyr::full_join(Add4LeapYear,
                                        sampleInfo[c("Code",
                                                     "isAfterFeb")],
                                        by=c("Code"))

        Add4LeapYear$Add2Shift =
            as.numeric(Add4LeapYear$isAfterFeb &
                       Add4LeapYear$isLeapYear)

        data = dplyr::full_join(data,
                                Add4LeapYear[c("Code",
                                               "Year",
                                               "Add2Shift")],
                                by=c("Code", "Year"))

        data$Shift = data$Shift + data$Add2Shift
        data$Date = data$Date - data$Shift

        data = dplyr::full_join(data,
                                sampleInfo[c("Code",
                                             "minDateRef",
                                             "minDate")],
                                by=c("Code"))
        
        tree("Removing useless data", 3, end=TRUE, inEnd=2,
             verbose=verbose)

        data = dplyr::select(data, -c(Year,
                                      Shift,
                                      Add2Shift,
                                      spStart,
                                      spEnd,
                                      dt2add))
        

    } else if (timeStep %in% c("month", "year-month")) {

        if (timeStep == "month") {
            tree("Monthly extraction", 1, verbose=verbose)
        } else if (timeStep == "year-month") {
            tree("Monthly extraction along years", 1, verbose=verbose)
        }
        tree("Sampling of the data", 2, verbose=verbose)

        samplePeriod$dRef =
            as.numeric(samplePeriod$refStart +
                       months(abs(samplePeriod$dt2add-1)) -
                       samplePeriod$refEnd)


        if (any(samplePeriod$dRef != 1)) {
            
            samplePeriod$dStart = as.numeric(substr(samplePeriod$spStart, 1, 2))
            samplePeriod$dEnd = as.numeric(substr(samplePeriod$spEnd, 1, 2))
            
            data = dplyr::full_join(data,
                                    samplePeriod[c("Code",
                                                   "dStart",
                                                   "dEnd")],
                                    by="Code")
            
            data = dplyr::filter(data,
                                 
            (refStart < refEnd)
            & dStart <= lubridate::day(Date)
            & lubridate::day(Date) <= dEnd
            
            |
            
            (refStart >= refEnd)
            & (lubridate::day(Date) <= dEnd
                | dStart <= lubridate::day(Date))
            
            )
            
            data = dplyr::select(data, -c(dStart,
                                          dEnd))
        }

        data = dplyr::select(data, -c(refStart,
                                      refEnd))

        # if (!is.null(keep)) {
        #     data_save = dplyr::select(data, -c(spStart,
        #                                        spEnd,
        #                                        dt2add))
        # }

        tree("Preparing date data for the extraction",
             end=TRUE, 2, verbose=verbose)
        tree("Computing of time indicators for each time serie",
             3, inEnd=2, verbose=verbose)

        if (timeStep == "year-month") {
            sampleInfo =
                dplyr::summarise(dplyr::group_by(data, Code),
                                 minDate=min(Date),
                                 minDateRef=
                                     as.Date(paste0(
                                         lubridate::year(minDate),
                                         "-",
                                         lubridate::month(minDate),
                                         "-01")),
                                 spStart=spStart[1],
                                 minSampleStart=
                                     lubridate::add_with_rollback(
                                                    as.Date(paste0(
                                                        lubridate::year(minDate),
                                                        "-01-",
                                                        spStart[1])),
                                                    months(lubridate::month(minDate)
                                                           -1)),
                                 maxDate=max(Date),
                                 spEnd=spEnd[1],
                                 maxSampleEnd=
                                     lubridate::add_with_rollback(
                                                    as.Date(paste0(
                                                        lubridate::year(maxDate),
                                                        "-01-",
                                                        spEnd[1])),
                                                    months(lubridate::month(maxDate) + dt2add[1] - 1)),
                                 maxSampleStart=
                                     lubridate::add_with_rollback(
                                                    as.Date(paste0(
                                                        lubridate::year(maxDate),
                                                        "-01-",
                                                        spStart[1])),
                                                    months(lubridate::month(maxDate) - 1)),
                                 .groups="drop")
            
        } else if (timeStep == "month") {
            sampleInfo =
                dplyr::summarise(dplyr::group_by(data, Code),
                                 minDate=min(Date),
                                 minDateRef=
                                     as.Date(paste0(
                                         lubridate::year(minDate),
                                         "-",
                                         lubridate::month(minDate),
                                         "-01")),
                                 spStart=spStart[1],
                                 minSampleStart=
                                     lubridate::add_with_rollback(
                                                    as.Date(paste0(
                                                        lubridate::year(minDate),
                                                        "-01-",
                                                        spStart[1])),
                                                    months(lubridate::month(minDate)
                                                           -1)),

                                 maxDate=max(Date),
                                 spEnd=spEnd[1],
                                 maxSampleEnd=
                                     lubridate::add_with_rollback(
                                                    as.Date(paste0(
                                                        lubridate::year(maxDate),
                                                        "-01-",
                                                        spEnd[1])),
                                                    months(lubridate::month(maxDate) + dt2add[1] - 1)),
                                 maxSampleStart=
                                     lubridate::add_with_rollback(
                                                    as.Date(paste0(
                                                        lubridate::year(maxDate),
                                                        "-01-",
                                                        spStart[1])),
                                                    months(lubridate::month(maxDate) - 1)),
                                 .groups="drop")

            monthInfo =
                dplyr::summarise(dplyr::group_by(data,
                                                 Code,
                                                 YM=format(Date,
                                                           "%Y-%m")),
                                 Date=Date[!duplicated(YM)],
                                 .groups="drop")
            monthInfo =
                dplyr::summarise(
                           dplyr::group_by(monthInfo,
                                           Code,
                                           Date=format(Date, "%m")),
                           nYear=dplyr::n(),
                           .groups="drop")
        }

        tree("Shifting the start of each year in order to speed extraction process", 3, inEnd=2, verbose=verbose)
        
        sampleInfo$Shift =
            lubridate::mday(sampleInfo$minSampleStart) - 1
        data = dplyr::full_join(data,
                                sampleInfo[c("Code",
                                             "Shift")],
                                by=c("Code"))
        
        data$Date = data$Date - data$Shift

        sampleInfo$dNAstart =
            pmax(0, as.numeric(sampleInfo$minDate -
                               sampleInfo$minSampleStart))
        sampleInfo$dNAend =
            pmax(0, as.numeric(sampleInfo$maxSampleEnd -
                               sampleInfo$maxDate))

        sampleStartInfo =
            sampleInfo[c("Code", "minSampleStart", "dNAstart")]
        names(sampleStartInfo) = c("Code", "Date", "dNA")
        sampleEndInfo =
            sampleInfo[c("Code", "maxSampleStart", "dNAend")]
        names(sampleEndInfo) = c("Code", "Date", "dNA")

        sampleInfoCompress = dplyr::bind_rows(sampleStartInfo,
                                              sampleEndInfo)

        data = dplyr::full_join(data,
                                sampleInfo[c("Code",
                                             "minDateRef",
                                             "minDate")],
                                by=c("Code"))
        
        tree("Removing useless data", 3, end=TRUE, inEnd=2,
             verbose=verbose)
        data = dplyr::select(data, -c(Shift,
                                      spStart,
                                      spEnd,
                                      dt2add))


        
    } else if (timeStep %in% c("season", "year-season")) {

        if (timeStep == "season") {
            tree("Seasonly extraction", 1, verbose=verbose)
        } else if (timeStep == "year-season") {
            tree("Seasonly extraction along years", 1, verbose=verbose)
        }
        tree(paste0("Creating of the conversion process from months ",
                    "to seasons based on seasons vector ",
                    paste0(Seasons, collapse=" - ")),
             2, verbose=verbose)
        nMonthSeasons = sapply(Seasons, nchar)
        
        get_Season = rep(Seasons, nMonthSeasons)
        
        idJan = (which(unlist(strsplit(paste0(Seasons,
                                              collapse=""),
                                       "")) == "D") + 1) %% 12
        
        get_Season = c(get_Season[idJan:12], get_Season[1:(idJan-1)])

        subSeasons = unlist(lapply(nMonthSeasons, seq, from=1)) - 1
        names(subSeasons) = NULL
        subSeasons = c(subSeasons[idJan:12],
                       subSeasons[1:(idJan-1)])

        addSeasons = unlist(lapply(nMonthSeasons, seq, to=1)) - 1
        names(addSeasons) = NULL
        addSeasons = c(addSeasons[idJan:12],
                       addSeasons[1:(idJan-1)])

        orderSeasons = get_Season[!duplicated(get_Season)]
        orderSeasons = orderSeasons[!is.na(orderSeasons)]
        nMonthOrderSeasons = sapply(orderSeasons, nchar)
        endSeasonsMonth = cumsum(nMonthOrderSeasons)
        startSeasonsMonth = endSeasonsMonth - nMonthOrderSeasons + 1
        idOrderJan = (which(unlist(strsplit(paste0(orderSeasons,
                                                   collapse=""),
                                            "")) == "D") + 1) %% 12
        startSeasonsMonth = (startSeasonsMonth - idOrderJan) %% 12 + 1
        
        SeasonsMonth = rep(startSeasonsMonth, nMonthOrderSeasons)
        SeasonsMonth = c(SeasonsMonth[idJan:12],
                         SeasonsMonth[1:(idJan-1)])

        tree("Sampling of the data", 2, verbose=verbose)

        samplePeriod$dRef =
            as.numeric(samplePeriod$refStart +
                       months(abs(samplePeriod$dt2add-1)) -
                       samplePeriod$refEnd)

        if (any(samplePeriod$dRef != 1)) {
            
            samplePeriod$dStart = as.numeric(substr(samplePeriod$spStart, 1, 2))
            samplePeriod$dEnd = as.numeric(substr(samplePeriod$spEnd, 1, 2))
            
            data = dplyr::full_join(data,
                                    samplePeriod[c("Code",
                                                   "dStart",
                                                   "dEnd")],
                                    by="Code")
            
            data = dplyr::filter(data,
                                 
            (refStart < refEnd)
            & dStart <= lubridate::day(Date)
            & lubridate::day(Date) <= dEnd
            
            |
            
            (refStart >= refEnd)
            & (lubridate::day(Date) <= dEnd
                | dStart <= lubridate::day(Date))
            
            )
            
            data = dplyr::select(data, -c(dStart,
                                          dEnd))
        }

        data = dplyr::select(data, -c(refStart,
                                      refEnd))

        # if (!is.null(keep)) {
        #     data_save = dplyr::select(data, -c(spStart,
        #                                        spEnd,
        #                                        dt2add))
        # }

        tree("Preparing date data for the extraction",
             end=TRUE, 2, verbose=verbose)

        tree("Computing of time indicators for each time serie",
             3, inEnd=2, verbose=verbose)

        
        sampleInfo =
            dplyr::summarise(dplyr::group_by(data, Code),
                             minDate=min(Date),
                             minDateRef=
                                 as.Date(paste0(
                                     lubridate::year(minDate),
                                     "-",
                                     lubridate::month(minDate),
                                     "-01")),
                             spStart=spStart[1],
                             minSampleStart=
                                 lubridate::add_with_rollback(
                                                as.Date(paste0(
                                                    lubridate::year(minDate),
                                                    "-01-",
                                                    spStart[1])),
                                                months(lubridate::month(minDate)
                                                       - 1 - subSeasons[lubridate::month(minDate)])),
                             maxDate=max(Date),
                             spEnd=spEnd[1],
                             maxSampleEnd=
                                 lubridate::add_with_rollback(
                                                as.Date(paste0(
                                                    lubridate::year(maxDate),
                                                    "-01-",
                                                    spEnd[1])),
                                                months(lubridate::month(maxDate) + dt2add[1] + addSeasons[lubridate::month(maxDate)] - 1)),
                             maxSampleStart=
                                 lubridate::add_with_rollback(
                                                as.Date(paste0(
                                                    lubridate::year(maxDate),
                                                    "-01-",
                                                    spStart[1])),
                                                months(lubridate::month(maxDate)
                                                       - 1 - subSeasons[lubridate::month(maxDate)])),
                             .groups="drop")        

        tree("Shifting the start of each year in order to speed extraction process", 3, inEnd=2, verbose=verbose)
        
        sampleInfo$Shift =
            lubridate::mday(sampleInfo$minSampleStart) - 1
        data = dplyr::full_join(data,
                                sampleInfo[c("Code",
                                             "Shift")],
                                by=c("Code"))
        
        data$Date = data$Date - data$Shift


        if (timeStep == "season") {
            data$Season = get_Season[lubridate::month(data$Date)]

            data$SeasonDate =
                lubridate::add_with_rollback(
                               data$Date,
                               - months(subSeasons[lubridate::month(data$Date)]))
            data$YearSeason =
                paste0(lubridate::year(data$SeasonDate),
                       "-",
                       get_Season[lubridate::month(data$SeasonDate)])

            seasonInfo =
                dplyr::summarise(dplyr::group_by(data,
                                                 Code,
                                                 YearSeason),
                                 Date=Date[!duplicated(YearSeason)],
                                 .groups="drop")
            seasonInfo =
                dplyr::summarise(
                           dplyr::group_by(seasonInfo,
                                           Code,
                                           Date=get_Season[lubridate::month(Date)]),
                           nYear=dplyr::n(),
                           .groups="drop")

            
        } else if (timeStep == "year-season") {
            data$SeasonDate =
                lubridate::add_with_rollback(
                               data$Date,
                               - months(subSeasons[lubridate::month(data$Date)]))
            data$YearSeason =
                paste0(lubridate::year(data$SeasonDate),
                       "-",
                       get_Season[lubridate::month(data$SeasonDate)])
            
            data_tmp =
                dplyr::summarise(dplyr::group_by(data,
                                                 Code,
                                                 YearSeason),
                                 Date_g=as.Date(paste0(
                                     lubridate::year(SeasonDate),
                                     "-",
                                     lubridate::month(SeasonDate),
                                     "-",
                                     spStart)),
                                 .groups="drop")

            data_tmp = dplyr::distinct(data_tmp)
            data = dplyr::full_join(data, data_tmp,
                                    by=c("Code", "YearSeason"))
        }

        sampleInfo$dNAstart =
            pmax(0, as.numeric(sampleInfo$minDate -
                               sampleInfo$minSampleStart))
        sampleInfo$dNAend =
            pmax(0, as.numeric(sampleInfo$maxSampleEnd -
                               sampleInfo$maxDate))

        sampleStartInfo =
            sampleInfo[c("Code", "minSampleStart", "dNAstart")]
        names(sampleStartInfo) = c("Code", "Date", "dNA")
        sampleEndInfo =
            sampleInfo[c("Code", "maxSampleStart", "dNAend")]
        names(sampleEndInfo) = c("Code", "Date", "dNA")
        

        sampleInfoCompress = dplyr::bind_rows(sampleStartInfo,
                                              sampleEndInfo)

        if (timeStep == "season") {
            sampleInfoCompress$Date =
                get_Season[lubridate::month(sampleInfoCompress$Date)]
            sampleInfoCompress =
                dplyr::summarise(dplyr::group_by(sampleInfoCompress,
                                                 Code, Date),
                                 dNA=sum(dNA),
                                 addYear=dplyr::n() - 1,
                                 .groups="drop")
        }

        data = dplyr::full_join(data,
                                sampleInfo[c("Code",
                                             "minDateRef",
                                             "minDate")],
                                by=c("Code"))
        
        tree("Removing useless data", 3, end=TRUE, inEnd=2,
             verbose=verbose)
        data = dplyr::select(data, -c(Shift,
                                      spStart,
                                      spEnd,
                                      dt2add))
    }

    tree("Grouping data", 1, verbose=verbose)

    if (timeStep == "none") {
        data = dplyr::group_by(data,
                               Code)
        colGroup = "Code"
        
    } else if (timeStep %in% c("year", "year-month", "month")) {
        if (timeStep == "year") {
            groupFormat = "%Y"
        } else if (timeStep == "year-month") {
            groupFormat = "%Y-%m"
        } else if (timeStep == "month") {
            groupFormat = "%m"
        }
        data = dplyr::group_by(data,
                               Code,
                               Date_g=format(Date,
                                             groupFormat))
        colGroup = c("Code", "Date_g")

    } else if (timeStep == "yearday") {
        data = dplyr::group_by(data,
                               Code,
                               Date_g=lubridate::yday(Date))
        colGroup = c("Code", "Date_g")
        
    } else {
        if (timeStep == "year-season") {
            data = dplyr::group_by(data,
                                   Code,
                                   Date_g,
                                   YearSeason)
            colGroup = c("Code", "Date_g", "YearSeason")
            
        } else if (timeStep == "season") {
            data = dplyr::group_by(data,
                                   Code,
                                   Date_g=Season)
            colGroup = c("Code", "Date_g")
        }
    }



    


    
    if (timeStep != "none") {
        nOK = data$minDateRef <= data$Date
        data = data[nOK,]
        if (any(isDate)) {
            minDateRef_save = dplyr::select(dplyr::ungroup(data),
                                            c(Code,
                                              minDateRef,
                                              minDate))
            minDateRef_save = dplyr::distinct(minDateRef_save,
                                              .keep_all=TRUE)
        }
        data = dplyr::select(data, -c("minDateRef", "minDate"))
    }

    tree("Application of the function",
         1, verbose=verbose)

    if (!is.null(keep)) {
        if (timeStep == "none") {
            keepDate = list(Date="Date")
            colGroup = c("Code", "Date")
        } else if (timeStep == "yearday") {
            keepDate = NULL
        } else {
            keepDate = NULL
        }
    } else {
        keepDate = NULL
        if (timeStep == "none") {
            colGroup = c("Code", "id")
        }
    }

    if (!is.null(keep) & !(timeStep %in% c("month",
                                           "season",
                                           "yearday"))) {
        data =
            dplyr::left_join(
                       data,
                       purrr::reduce(
                                  .x=lapply(
                                      1:nfunct,
                                      apply_extraction,
                                      data=data,
                                      colArgs=colArgs,
                                      otherArgs=otherArgs,
                                      funct=funct,
                                      keepDate=keepDate,
                                      timeStep=timeStep,
                                      colGroup=colGroup),
                                  .f=dplyr::full_join, by=colGroup),
                       by=colGroup)
    } else {
        data = purrr::reduce(.x=lapply(1:nfunct,
                                       apply_extraction,
                                       data=data,
                                       colArgs=colArgs,
                                       otherArgs=otherArgs,
                                       funct=funct,
                                       keepDate=keepDate,
                                       timeStep=timeStep,
                                       colGroup=colGroup),
                             .f=dplyr::full_join, by=colGroup)
    }

    data = dplyr::select(data, -dplyr::starts_with("id"))

    if (!is.null(keep) & timeStep %in% c("yearday")) {
        data$Date_g = as.Date(data$Date_g-1,
                              origin=as.Date("1970-01-01"))
    }

    
    nValue = nfunct
    
    
    tree("Cleaning extracted tibble", 1, verbose=verbose)

    if (timeStep != "none" & any(isDate)) {
        data = dplyr::full_join(data,
                                minDateRef_save,
                                by="Code")
        rm (minDateRef_save)
    }

    infinite2NA = function (X) {
        if (tibble::is_tibble(X)) {
            X = dplyr::mutate(X, dplyr::across(.fns=infinite2NA))
        } else {
            X[is.infinite(X)] = NA
        }
        return (X)
    }
    
    data = dplyr::mutate(data,
                         dplyr::across(.cols=
                                           dplyr::starts_with(
                                                      paste0("ValueEX",
                                                             1:nValue)),
                                       .fns=infinite2NA),
                         .keep="all")
    
    if (timeStep == "year") {
        sampleInfoCompress$Date = format(sampleInfoCompress$Date,
                                         groupFormat)
        data$nDay = 365.25
        
    } else if (timeStep == "year-month") {
        sampleInfoCompress$Date = format(sampleInfoCompress$Date,
                                         groupFormat)
        data$nDay = 30.4375

    } else if (timeStep == "month") {
        sampleInfoCompress$Date = format(sampleInfoCompress$Date,
                                         groupFormat)
        data = dplyr::full_join(data,
                                dplyr::rename(monthInfo,
                                              Date_g=Date),
                                by=c("Code", "Date_g"))
        data$nDay = 30.4375*data$nYear
        data = dplyr::select(data, -nYear)

    } else if (timeStep == "year-season") {
        data$nDay = nchar(gsub("^.*-", "", data$YearSeason)) * 30.4375
        
    } else if (timeStep == "season") {
        data = dplyr::full_join(data,
                                dplyr::rename(seasonInfo,
                                              Date_g=Date),
                                by=c("Code", "Date_g"))

        data$nDay = nchar(data$Date_g) * 30.4375 *
            data$nYear
        data = dplyr::select(data, -nYear)
    }

    if (timeStep %in% c("none", "yearday")) {
        compute_NApct = function (nNA, n) {
            NApct = round(nNA/n * 100, 1)
            return (NApct)
        }
        data = dplyr::mutate(data,
                             dplyr::across(.cols=
                                               dplyr::starts_with(
                                                          paste0("nNA",
                                                                 1:nValue)),
                                           .fns=compute_NApct ,
                                           .names=paste0("NApct{1:",
                                                         nValue, "}"),
                                           n=n),
                             .keep="all")

        data = dplyr::select(data, -c(paste0("nNA",
                                             1:nValue), n))
        
    } else {
        data = dplyr::full_join(data,
                                dplyr::rename(sampleInfoCompress[
                                           c("Code",
                                             "Date",
                                             "dNA")], Date_g=Date),
                                by=c("Code", "Date_g"))

        
        data$dNA[is.na(data$dNA)] = 0

        compute_NApct = function (nNA, dNA, nDay) {
            NApct = round((nNA + dNA)/nDay * 100, 1)
            return (NApct)
        }
        data = dplyr::mutate(data,
                             dplyr::across(.cols=
                                               dplyr::starts_with(
                                                          paste0("nNA",
                                                                 1:nValue)),
                                           .fns=compute_NApct ,
                                           .names=paste0("NApct{1:",
                                                         nValue, "}"),
                                           dNA=dNA,
                                           nDay=nDay),
                             .keep="all")
        
        data = dplyr::full_join(data,
                                samplePeriod[c("Code",
                                               "spStart")],
                                by="Code")


        if (!(timeStep %in% c("month", "year-season", "season", "yearday"))) {
            data =
                dplyr::mutate(dplyr::group_by(data, Code),
                              Date_g=as.Date(paste0(Date_g,
                                                    "-",
                                                    spStart[1])),
                              .keep="all")
        }

        if (any(isDate) & timeStep == "month") {
            data =
                dplyr::mutate(dplyr::group_by(data, Code),
                              Date_g=as.Date(paste0(
                                  lubridate::year(minDate[1]),
                                  "-",
                                  Date_g,
                                  "-",
                                  spStart[1])),
                              .keep="all")
        }

        if (any(isDate) & timeStep == "season") {
            data =
                dplyr::mutate(dplyr::group_by(data, Code),
                              Date_g=as.Date(paste0(
                                  lubridate::year(minDate[1]),
                                  "-",
                                  startSeasonsMonth[
                                      match(Date_g,
                                            names(startSeasonsMonth))],
                                  "-",
                                  spStart[1])),
                              .keep="all")
        }
        
        data = dplyr::select(data, -c(paste0("nNA",
                                             1:nValue),
                                      n,
                                      dNA,
                                      nDay,
                                      spStart))   
    }



    

    
    if (any(isDate)) {
        if (length(isDate) != nfunct) {
            isDate = rep(isDate[1], nfunct)
        }
        data = convert_dateEX(data, isDate, nValue=nValue,
                              verbose=verbose)
    }

    if (timeStep != "none") {
        if (!is.null(keep) &
            !(timeStep %in% c("month", "season", "yearday"))) {
            data = dplyr::select(data, -"Date_g") 
        } else {
            data = dplyr::rename(data, Date=Date_g)
        }
    }

    
    if (!is.null(NApct_lim)) {
        data = NA_filter(data, timeStep=timeStep,
                         nValue=nValue,
                         NApct_lim=NApct_lim,
                         mod=NULL, verbose=verbose)
    }

    tree("Last cleaning", 1, end=TRUE, verbose=verbose)

    if (onlyDate4Season) {
        data = dplyr::select(data, -YearSeason)
    }

    if (!rmNApct & is.null(keep) & !compress) {
        if (nfunct == 1) {
            data = dplyr::rename(data, NApct=NApct1)
            
        } else {
            for (i in 1:nfunct) {
                data=
                    dplyr::rename(data,
                                  !!paste0("NApct",
                                           "_",
                                           nameEX[i]) :=
                                      !!paste0("NApct", i))
            }
        }
    }
    if (rmNApct | compress) {
        data = dplyr::select(data, -c(paste0("NApct",
                                             1:nValue)))
    }

    if (timeStep == "yearday") {
        data = dplyr::filter(data, Date < 366)
    }
    
    if (!is.null(keep) & !(timeStep %in% c("month", "season"))) {
        if (timeStep %in% c("yearday")) {
            data$Date = as.Date(data$Date-1, origin=as.Date("1970-01-01"))
            
        }
        data = dplyr::select(data, Code, dplyr::everything())
        data = dplyr::relocate(data, Date, .after=Code)
    }

    idCode = which(names(data) == "Code")
    if (!(timeStep == "none" & is.null(keep))) {
        idDate = which(names(data) == "Date")
    }
    
    idValue = which(grepl("ValueEX[[:digit:]]", names(data)))

    if (timeStep == "yearday") {
        names_save[idDate_save] = "Yearday"
        data = dplyr::filter(data, Date < 366)
    } 

    if (isDateColArgs) {
        names_save = names_save[-length(names_save)]
        idValue_save = idValue_save[-length(idValue_save)]
    }

    if (timeStep == "none" & is.null(keep)) {
        names(data)[c(idCode, idValue)] =
            names_save[c(idCode_save, idValue_save)]
    } else {
        names(data)[c(idCode, idDate, idValue)] =
            names_save[c(idCode_save, idDate_save, idValue_save)] 
    }

    if (!is.null(keep) & !compress) {
        test = grepl("Value[[:digit:]]", names(data))
        if (any(test)) {
            
            idValue_keep = which(test)
            idIn =
                which(names_keepSave[idValue_keepSave] %in%
                      names(data))

            if (length(idIn) > 0) {

                idRm = idValue_keep[idIn]
                
                data = data[-idRm] 
                
                idValue_keep = idValue_keep[-idIn]
                idValue_keepSave = idValue_keepSave[-idIn]
            }
            names(data)[idValue_keep] =
                names_keepSave[idValue_keepSave]
        }
    }

    if (compress & timeStep %in% c("year-season", "year-month",
                                   "month", "season")) {
        if (timeStep == "season") {
            Ref = Seasons
            expandRef = Seasons
            shiftRef = startSeasonsMonth
            
        } else if (timeStep == "year-season") {
            data = dplyr::select(data, -"YearSeason")
            Ref = get_Season
            expandRef = Seasons
            shiftRef = startSeasonsMonth
            
        } else if (timeStep %in% c("year-month", "month")) {
            Ref = format(seq.Date(as.Date("1970-01-01"),
                                  as.Date("1970-12-01"),
                                  "month"), "%b")
            Ref = gsub("û", "u", Ref)
            Ref = gsub("é", "e", Ref)
            Ref = gsub("[.]", "", Ref)
            expandRef = Ref
            shiftRef = 1:12
        } 

        dateName = names_save[idDate_save]
        valueName = names_save[idValue_save]
        
        if (timeStep %in% c("year-month", "year-season")) {
            data = dplyr::mutate(
                              data,
                              Ref=
                                  Ref[lubridate::month(get(dateName))],
                              !!dateName:=
                                  lubridate::year(get(dateName)))
        } else if (timeStep == "season") {
            data = dplyr::rename(data,
                                 Ref=Date)
        } else if (timeStep == "month") {
            data$Ref = Ref[as.numeric(data[[dateName]])]
            data = dplyr::select(data, -dateName)
        }

        data =
            tidyr::pivot_wider(
                       data,
                       names_from=Ref,
                       values_from=valueName,
                       names_glue="{.value}_{Ref}")


    }

    if ((compress & timeStep %in%
         c("year-season", "year-month", "month", "season")) |
        expand & timeStep %in% c("none", "year")) {

        if (!is.null(suffix)) {
            valueName = c()
            for (i in 1:length(suffix)) {
                ok = grepl(suffix[i], names(data), fixed=TRUE)
                valueName_no_suffix = gsub(suffix[i], "",
                                           names(data)[ok],
                                           fixed=TRUE)
                valueName = c(valueName, valueName_no_suffix)
                valueName_suffix = paste0(valueName_no_suffix,
                                          suffix[i])
                names(data)[ok] = valueName_suffix
            }
            valueName = valueName[!duplicated(valueName)]
        }

        if (timeStep %in% c("year-month", "year-season")) {
            data[[dateName]] = as.Date(paste0(data[[dateName]],
                                              "-01-01"))
        }
    }

    if (!is.null(keep)) {
        if (any(keep == "all")) {
            names_to_keep = names(data)
        } else {
            names_to_keep =
                c(names_save[idCode_save],
                  names_save[idDate_save],
                  names_save[idValue_save][names_save[idValue_save] %in% keep])
            names_to_keep = names_to_keep[names_to_keep %in% names(data)]
        }
        data = dplyr::select(data, names_to_keep)
    }

    data = tidyr::unnest(data,
                         dplyr::everything(),
                         names_sep="_")
    
    if (length(ID_colnames) > 1) {
        data = tidyr::separate(data, col="ID",
                               into=ID_colnames, sep="_")
    }
    
    if (compress & expand) {
        
        is.character_or_date = function (x) {
            is.character(x) | lubridate::is.Date(x)
        }
        if (!is.null(suffix)) {
            valueName_suffix = lapply(valueName, paste0, suffix)
        } else {
            valueName_suffix = valueName
        }
        
        valueName_select = lapply(
            valueName_suffix,
            append,
            x=names(data)[sapply(data,
                                 is.character_or_date)])
        data = lapply(valueName_select, dplyr::select,
                      .data=data)
        names(data) = valueName

        if (timeStep %in% c("year-month", "year-season")) {
            for (i in 1:length(valueName)) {
                dateName =
                    names(data[[i]])[sapply(data[[i]],
                                            lubridate::is.Date)]
                data[[i]] =
                    dplyr::mutate(
                               data[[i]],
                               !!dateName:=
                                   lubridate::add_with_rollback(
                                                  get(dateName),
                                                  months(shiftRef[i]
                                                         -1)))
            }
        }
    }
    
    if (verbose) {
        print(data)
    }
    
    return (data)
}



apply_extraction = function (i, data, colArgs, otherArgs,
                              funct, keepDate, timeStep, colGroup) {
    
    colArg = colArgs[[i]]
    otherArg = otherArgs[[i]]
    f = funct[[i]]

    data$isNA =
        is.na(rowSums(
            dplyr::mutate_all(data[unlist(colArg)],
                              as.numeric)))

    if (i == 1) {
        data = dplyr::summarise(
                          data,
                          !!!rlang::data_syms(keepDate),
                          !!paste0("ValueEX", i) :=
                              f(!!!rlang::data_syms(colArg),
                                !!!otherArg),
                          !!paste0("nNA", i) :=
                              sum(isNA),
                          n=dplyr::n(),
                          id=1:max(c(length(get(paste0("ValueEX", i))), 1)),
                          .groups='drop')
    } else {
        data = dplyr::summarise(
                          data,
                          !!!rlang::data_syms(keepDate),
                          !!paste0("ValueEX", i) :=
                              f(!!!rlang::data_syms(colArg),
                                !!!otherArg),
                          !!paste0("nNA", i) :=
                              sum(isNA),
                          id=1:max(c(length(get(paste0("ValueEX", i))), 1)),
                          .groups='drop')
    }
    return (data)
}



fix_samplePeriod = function (samplePeriod, data_code=NULL, args=NA,
                             suffix=NULL,
                             refDate="1972", sampleFormat="%m-%d",
                             verbose=FALSE) {

    if (is.function(samplePeriod[[1]]) & sampleFormat == "%m-%d") {
        dataM = process_extraction(data=data_code,
                                   funct=list(XM=mean),
                                   funct_args=args,
                                   suffix=suffix,
                                   timeStep="month",
                                   rmNApct=TRUE,
                                   verbose=FALSE)


        if (!is.null(suffix)) {
            XM = paste0("XM", suffix)
        } else {
            XM = "XM"
        }
        samplePeriod = dataM$Date[dataM[[XM]] ==
                                  samplePeriod[[1]](dataM[[XM]])]
        samplePeriod = paste0(samplePeriod, "-01")
    }

    samplePeriod = unlist(samplePeriod)
    
    if (length(samplePeriod) == 1 | any(is.na(samplePeriod))) {
        if (length(samplePeriod) == 1) {
            
            tree("Only start of the sample period was given", 3,
                 inEnd=2,
                 verbose=verbose)
            samplePeriod =
                c(samplePeriod,
                  format(as.Date(paste0(refDate,
                                        '-',
                                        samplePeriod)) - 1,
                         sampleFormat))
            
        } else if (any(is.na(samplePeriod))) {
            idNA = which(is.na(samplePeriod))
            if (idNA == 1) {
                tree("Only end of the sample period was given", 3,
                     inEnd=2,
                     verbose=verbose)
                samplePeriod[1] =
                    format(as.Date(paste0(refDate,
                                          '-',
                                          samplePeriod[2])) + 1,
                           sampleFormat)
                
            } else if (idNA == 2) {
                tree("Only start of the sample period was given", 3,
                     inEnd=2,
                     verbose=verbose)
                samplePeriod[2] =
                    format(as.Date(paste0(refDate,
                                          '-',
                                          samplePeriod[1])) - 1,
                           sampleFormat)
            }
        }
    }
    return (samplePeriod)
}



fix_samplePeriod_FUCKING29FEB = function (samplePeriod,
                                          sampleFormat) {
    samplePeriod = unlist(samplePeriod)
    if (sampleFormat == "%m-%d") {
        samplePeriod[samplePeriod == "02-29"] = "02-28"
    }
    return (samplePeriod)
}

add = function (x, y) {x+y}

reduce_convert_data_hide = function (data, i, isDate) {
    if (isDate[i]) {
        Value = paste0("ValueEX", i)
        data = dplyr::mutate(dplyr::group_by(data, Code),
                             dplyr::across(.cols=dplyr::starts_with(
                                                            Value),
                                           .fns=add,
                                           y=Shift),
                             dplyr::across(.cols=dplyr::starts_with(
                                                            Value),
                                           .fns=convert_data_hide),
                             .keep="all")
    }
    return (data)
}

convert_data_hide = function (Value) {
    Month = Value / (365.25/12)        
    MonthNoNA = Month[!is.na(Month)]    
    fact = 2*pi/12
    monthMean_raw = CircStats::circ.mean(fact * MonthNoNA) / fact
    monthMean = (monthMean_raw + 12) %% 12

    upLim = round(monthMean + 6, 2)
    lowLim = round(monthMean - 6, 2)

    above = Month > upLim
    above[is.na(above)] = FALSE
    below = Month < lowLim
    below[is.na(below)] = FALSE
    
    Value[above] = Value[above] - 366
    Value[below] = Value[below] + 365
    return (Value)
}

#' @title convert_dateEX
#' @description Convert the index to date format for the extracted variables specified in the isDate argument. The date format is based on the date column of the input tibble and the function "convert_data_hide" is used for the conversion.
#' @param data A tibble containing a column named "Date" which corresponds to the index of each sample and one or several columns named "ValueEXx" (x being a number) that correspond to the extracted variables.
#' @param isDate A logical vector indicating whether the columns named "ValueEXx" should be converted to date format or not
#' @param nValue Number of columns named "ValueEXx"
#' @param isColArgs A logical vector indicating whether the columns named "ValueEXx" corresponds to column arguments of function used in the extraction process
#' @param verbose A logical, if TRUE output to the console will be provided
#' @return A tibble containing a column named "Date" which corresponds to the date of each sample and one or several columns named "ValueEXx" (x being a number) that correspond to the extracted variables.
#' @note documentation generated by chatGPT
#' @export
convert_dateEX = function(data, isDate, nValue,
                          verbose=TRUE) {

    tree('Converting index to date', 1, verbose=verbose)
    data$sampleStart = pmax(data$Date_g,
                            pmax(data$minDateRef,
                                 data$minDate))    
    data$Shift = lubridate::yday(data$sampleStart) - 1
    
    nfunct = length(isDate)

    data = purrr::reduce(.x=1:nfunct, .f=reduce_convert_data_hide,
                         isDate=isDate,
                         .init=data)
    data = dplyr::select(data, -c(minDateRef,
                                  minDate,
                                  sampleStart,
                                  Shift))
    return (data)
}


## 3. NA FILTER AFTER EXTRACTION _____________________________________
#' @title NA filter
#' @description Filters the rows with a NA percentage above the threshold given in parameter.
#' @param data Data after extraction that should be filtered.
#' @param timeStep Character string indicating the time step of the extraction, could be 'none' if the time step doesn't matter, 'year' or 'year-month'.
#' @param nValue Number of values extracted.
#' @param NApct_lim Percentage limit of NA above which rows will be removed. Default is 1.
#' @param mod A list of modification to store comments of filtering applied.
#' @param verbose Logical, when true prints message indicating the removal of data due to high NA percentage
#' @return data filtered by the percentage of NA allowed in input.
#' @importFrom lubridate is.Date
#' @note documentation generated by chatGPT
#' @export
NA_filter = function (data, timeStep, nValue, NApct_lim=1,
                      mod=NULL, verbose=TRUE) {

    tree(paste0('Removing data if NA percentage is strictly above ',
                NApct_lim, " %"), 1, verbose=verbose)

    NApct2filter = function (X, NApct_lim) {
        filter = X > NApct_lim
        filter[is.na(filter)] = FALSE
        return (filter)
    }
    
    data = dplyr::mutate(data,
                         dplyr::across(.cols=
                                           dplyr::starts_with(
                                                      paste0("NApct",
                                                             1:nValue)),
                                       .fns=NApct2filter,
                                       NApct_lim=NApct_lim,
                                       .names=paste0("filter{1:",
                                                     nValue, "}")),
                         .keep="all")
    
    filter2NA = function (X, filter) {
        X[filter] = NA
        return (X)
    }
    
    data[paste0("ValueEX", 1:nValue)] =
        Map(filter2NA,
            X=data[paste0("ValueEX", 1:nValue)],
            filter=data[paste0("filter", 1:nValue)])

    # codeFilter = data$Code[data$filter]
    # codeFilter = codeFilter[!duplicated(codeFilter)]
    # if (timeStep == "none") {
    #     dateFilter = ""
    # } else {
    #     if (lubridate::is.Date(data$Date[1])) {
    #         dateFilter = format(data$Date[data$filter], "%Y")
    #     } else {
    #         dateFilter = data$Date[data$filter]
    #     }
    # }
    # Nmod = length(codeFilter)

    # if (!is.null(mod) & !identical(codeFilter, character(0))) {
    #     for (i in 1:Nmod) {
    #         mod =
    #             add_mod(mod, codeFilter[i],
    #                     type='Filtering of NA percentage after EXtraction',
    #                     fun_name='NA assignment',
    #                     comment=paste0('Removal of year ', dateFilter[i]))
    #     }
    # }

    data = dplyr::select(data, -paste0("filter", 1:nValue))

    if (!is.null(mod)) {
        res = list(data=data, mod=mod)
        return (res)
    } else {
        return (data)
    }
}



## 2. MANAGES MISSING DATA ___________________________________________
### 2.1. Long missing period over several years ______________________
missing_year_hide = function (Value, Date, NAyear_lim) {

    DateNA = Date[is.na(Value)]
    dDateNA = diff(DateNA)
    if (length(dDateNA) == 0) {
        return (Value)
    }
    dDateNA = c(10, dDateNA)

    idJump = which(dDateNA != 1)
    NJump = length(idJump)

    if (NJump > 0) {
        
        for (i in 1:NJump) {
            idStartNA = idJump[i]
            
            if (i < NJump) {
                idEndNA = idJump[i+1] - 1
            } else {
                idEndNA = length(DateNA)
            }

            StartNA = DateNA[idStartNA]
            EndNA = DateNA[idEndNA]
            
            duration = as.numeric((EndNA - StartNA)/365.25)
            
            if (duration >= NAyear_lim) {
                
                Start = min(Date, na.rm=TRUE)
                End = max(Date, na.rm=TRUE)
                
                Before = StartNA - Start
                After = End - EndNA
                if (Before < After) {
                    Value[Date <= StartNA] = NA
                    start = Start
                    end = StartNA
                } else {
                    Value[Date >= EndNA] = NA
                    start = EndNA
                    end = End
                }
            }
        }
    }
    return (Value)
}

#' @title Missing year
#' @description This function will check for any continuous missing period longer than a specified threshold of years in each time series and assign them as missing values.
#' @param data A data.frame containing at least a date column, a numeric column and a column indicating a name of time series, in order to identify them.
#' @param nValue number of numeric column
#' @param NAyear_lim threshold of year duration for missing period.
#' @param mod An object of class modification, it will store all modification made to the data
#' @param verbose logical for print messages
#' @return return the dataframe with identified missing period as NA
#' @note documentation generated by chatGPT
#' @export
#' @note documentation generated by chatGPT
#' @export
missing_year = function (data, nValue, NAyear_lim=10,
                         mod=NULL, verbose=TRUE) {

    tree("Missing year", 1, verbose=verbose)
    tree(paste0('Checking missing continuous periods longer than ',
                NAyear_lim, ' years'), 2, is.null(mod), verbose=verbose)

    dataMOD = dplyr::mutate(
                         dplyr::group_by(data, Code),
                         dplyr::across(paste0("Value",
                                              1:nValue),
                                       missing_year_hide,
                                       Date=Date,
                                       NAyear_lim=NAyear_lim),
                         .keep="all")

    # if (!is.null(mod)) {
    #     tree('Wrinting modifications', 2, !is.null(mod),
    #          verbose=verbose)        
    #     isCorr = is.na(df_Value$Value) != is.na(data$Value)
    #     CodeCorr = df_Value$Code[isCorr]
    #     CodeCorr = CodeCorr[!duplicated(CodeCorr)]

    #     for (code in CodeCorr) {

    #         df_Value_code = df_Value[df_Value$Code == code,]
    #         data_code = data[data$Code == code,]

    #         isCorr_code = is.na(df_Value_code$Value) != is.na(data_code$Value)

    #         DateCorr_code = df_Value_code$Date[isCorr_code]

    #         start = min(DateCorr_code)
    #         end = max(DateCorr_code)
    
    #         mod =
    #             add_mod(mod, code,
    #                     type='Missing data management',
    #                     fun_name='NA assignment',
    #                     comment=paste('From ', start,
    #                                   ' of measurements',
    #                                   ' to ', end, sep=''))
    #     }
    # }

    # replace2NA = function (X) {
    #     X = replace(X, list=which(is.na(X)), value=NA)
    #     return (X)
    # }
    # data = dplyr::mutate(data,
    #                      dplyr::across(unlist(colArgs),
    #                                    replace2NA))


    data[paste0("Value", 1:nValue)] = dataMOD[paste0("Value", 1:nValue)]

    if (!is.null(mod)) {
        res = list(data=data, mod=mod)
        return (res)
    } else {
        return (data)
    }
}
