# Copyright 2021-2023 Louis Héraut (louis.heraut@inrae.fr)*1,
#                     Éric Sauquet (eric.sauquet@inrae.fr)*1
#
# *1   INRAE, France
#
# This file is part of EXstat R package.
#
# EXstat R package is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# EXstat R package is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with EXstat R package.
# If not, see <https://www.gnu.org/licenses/>.


#' @title process_trend
#' @description Applies Mann-Kendall statistical test to extracted
#' variable in order to determine the existence or not of a trend in
#' the data.
#' @param data A tibble with at least three columns : date, numeric values, and a character column for names of time series.
#' The trend analysis will be performed on the numeric column.
#' @param MK_level Numeric value between 0 and 1, the level used in the Mann-Kendall statistical test.
#' @param timeDep_option Character indicating the time dependency option of the MK test.
#' @param verbose Logical, if true will print detailed information.
#' @param ... other arguments passed to function \code{GeneralMannKendall_WRAP}
#' @return A table which specifies per line the name of the time series the value 'p', the value 'stat' and 'a' the slope of Theil-Sen. If the 'p' value is less than 0.1 and the slope 'a' is positive, the associated time serie shows an increasing linear trend which can be represented by the equation 'Y = a*X + b ' with 'a' the Type I error of 10% or 90% confidence.
#' @examples
#' # Date
#' Start = as.Date("1972-01-01")
#' End = as.Date("2020-12-31")
#' Date = seq.Date(Start, End, by="day")
#' 
#' # Value to analyse
#' set.seed(100)
#' X = seq(1, length(Date))/1e4 + runif(length(Date), -100, 100)
#' X[as.Date("2000-03-01") <= Date & Date <= as.Date("2000-09-30")] = NA
#'
#' # Creation of tibble
#' data = dplyr::tibble(Date=Date, ID="serie A", X=X)
#'
#' # Extraction
#' dataEX = process_extraction(data=data,
#'                             samplePeriod=c("05-01",
#'                                            "11-30"),
#'                             funct=max,
#'                             na.rm=TRUE,
#'                             period=c(as.Date("1990-01-01"),
#'                                      as.Date("2020-12-31")),
#'                             timeStep="year")
#'
#' trendEX = process_trend(data=dataEX)
#' trendEX
#' @importFrom rlang .data
#' @note documentation generated by chatGPT
#' @export
process_trend = function (dataEX,
                          metaEX=NULL,
                          MK_level=0.1,
                          timeDep_option="INDE",
                          # isFDR=FALSE,
                          # FDR_level=0.1,
                          take_not_signif_into_account=TRUE,
                          period_trend=NULL,
                          period_change=NULL,
                          exProb=0.01,
                          verbose=FALSE,
                          ...) {

    tree("TREND ANALYSE", 0, verbose=verbose)
    
    names_save = names(dataEX)
    idValue_save = c()
    for (id in 1:ncol(dataEX)) {
        x = dataEX[[id]]

        if (is.character(x)) {
            idCode_save = id
        } else if (lubridate::is.Date(x)) {
            idDate_save = id
        } else if (is.numeric(x)) {
            if (names_save[id] == "NApct") {
                idNA_save = id
            } else {
                idValue_save = c(idValue_save, id)
            }
        }
    }
    
    names(dataEX)[c(idCode_save, idDate_save, idValue_save)] =
        c("Code", "Date", "Value")



    if (is.null(period_trend)) {
        nPeriod_trend = 1
    } else {
        nPeriod_trend = length(period_trend)
    }

    trendEX = dplyr::tibble()
    
    for (j in 1:nPeriod_trend) {

        if (is.null(period_trend)) {
            dataEX_period = dataEX
        } else {
            period = period_trend[[j]]
            dataEX_period = dplyr::filter(dataEX,
                                          min(period) <= Date &
                                          Date <= max(period))
        }
        
        tree("Grouping dataEX by code", 1, verbose=verbose)
        # Group dataEX accordingly to group.names
        dataEX_period = dplyr::group_by(dataEX_period, Code)

        tree("Statistical test",
             1, verbose=verbose)

        tree(paste0("Application of the Mann-Kendall statistical test ",
                    "with a level of ",
                    round(MK_level*100), " % and ",
                    timeDep_option, " time dependency option"),
             2, verbose=verbose)
        
        # 1pply function on values accounting for grouping variables
        # 'group.names"
        trendEX_period =
            dplyr::summarise(dataEX_period,
                             GeneralMannKendall_WRAP(
                                 Value,
                                 level=MK_level,
                                 timeDep_option=timeDep_option,
                                 ...))
        
        tree("Estimation of other variable",
             1, end=TRUE, verbose=verbose)
        trendEX_period = get_intercept(dataEX_period, trendEX_period, verbose=verbose)
        trendEX_period = get_period(dataEX_period, trendEX_period, verbose=verbose)

        if (nrow(trendEX) == 0) {
            trendEX = trendEX_period
        } else {
            trendEX = dplyr::bind_rows(trendEX,
                                       trendEX_period)
        }
    }

    if (!is.null(metaEX)) {
        trendEX = dplyr::bind_cols(trendEX,
                                   var=names_save[idValue_save])
        trendEX = get_valueExtremes(dataEX, metaEX, trendEX,
                                    take_not_signif_into_account=take_not_signif_into_account,
                                    period_change=period_change,
                                    exProb=exProb)
    }
    
    # if (isFDR) { ### /!\ pas ok
    #     dataEX.final$p.FDR =
    #         fieldSignificance_FDR(dataEX.final$p,
    #                               level=FDR_level)
    # }

    idCode = which(names(trendEX) == "Code")

    names(trendEX)[c(idCode)] =
        names_save[c(idCode_save)]

    return (trendEX)
}



#### 2.3.2. Period of trend analysis _________________________________
#' @title Period of trend analysis
#' @description Computes the start and end of the period for a trend analysis based on the available dataEX.
#' @param dataEX A tibble containing at least the following columns: a date column, a unique numeric column for the values to be analyzed, and a character column for the names of the time series used for grouping.
#' @param trendEX A tibble containing the result of the trend analysis
#' @param verbose If set to true, function will output the progress of the computation
#' @return A tibble containing the trend analysis results with additional columns for the start and end of the period.
#' @note documentation generated by chatGPT
#' @export
get_period = function (dataEX, trendEX, verbose=TRUE) {

    tree("Computing of the optimal periods of trend analysis",
         2, end=TRUE, inEnd=1, verbose=verbose)

    Period = dplyr::summarise(dplyr::group_by(dataEX, Code),
                              start=min(Date, na.rm=TRUE),
                              end=max(Date, na.rm=TRUE),
                              period=list(c(start, end)))
    
    trendEX = dplyr::full_join(trendEX,
                               dplyr::select(Period,
                                             c("Code",
                                               "period")),
                               by="Code")
    return (trendEX)
}

#### 2.3.3. Intercept of trend _______________________________________
#' @title Intercept of trend
#' @description Computes the intercept values of linear trends using the first order values of trends and the dataEX on which the analysis is performed.
#' @param dataEX DataEX frame that contains at least columns for "Code","Date" and "Value"
#' @param trendEX DataEXframe that contains the result of trend analysis
#' @param verbose logical value. If set to True, it print the result of the computation.
#' @return A dataframe which contains the input dataframe trendEX with an additional column 'b' that represents the intercept of the trend.
#' @note documentation generated by chatGPT
#' @export
get_intercept = function (dataEX, trendEX,
                          verbose=TRUE) {

    tree("Computing of the intercept of trend",
         2, inEnd=1, verbose=verbose)
    
    MU_X = dplyr::summarise(dplyr::group_by(dataEX, Code),
                            mu_X=mean(Value, na.rm=TRUE))

    MU_t = dplyr::summarise(dplyr::group_by(dataEX, Code),
                            mu_t=as.numeric(mean(Date,
                                                 na.rm=TRUE)) /
                            mean(as.numeric(diff(Date)), na.rm=TRUE))

    analyse = dplyr::tibble(Code=trendEX$Code,
                            a=trendEX$a,
                            mu_X=MU_X$mu_X,
                            mu_t=MU_t$mu_t)
    
    B = dplyr::summarise(dplyr::group_by(analyse, Code),
                         b=mu_X - mu_t * a)
    
    trendEX = dplyr::full_join(trendEX, B, by="Code")

    return (trendEX)
}



#' @title Extremes
#' @export
get_valueExtremes = function (dataEX, metaEX, trendEX,
                              take_not_signif_into_account=TRUE,
                              period_change=NULL,
                              exProb=0.01) {

    Code = levels(factor(dataEX$Code))
    nCode = length(Code)
    Period = unique(trendEX$period)
    nPeriod = length(Period)
    Var =  levels(factor(trendEX$var))
    nVar = length(Var)

    trendEX$trend = NA

    for (j in 1:nPeriod) {
        period = Period[[j]]

        if (!is.null(period_change)) {
            trendEX$change = NA
            trendEX$period_change = NA 
            # dataMean_tmp = array(rep(NA, nVar*nCode),
            #                     dim=c(nVar, nCode))
        }

        for (k in 1:nCode) {
            code = Code[k]
            
            for (i in 1:nVar) {
                var = Var[i]
                normalize = metaEX$normalize[metaEX$var == var]
                # is_date = metaEX$is_date[metaEX$var == var]

                trendEX_period_code_var =
                    trendEX[sapply(lapply(trendEX$period,
                                          '==', period), all) &
                            trendEX$Code == code &
                            trendEX$var == var,]
                
                Start = period[1]
                End = period[2]
                dataEX_period_code = dataEX[dataEX$Date >= Start &
                                            dataEX$Date <= End &
                                            dataEX$Code == code,]

                Ntrend = nrow(trendEX_period_code_var)
                if (Ntrend > 1) {
                    trendEX_period_code_var = trendEX_period_code_var[1,]
                }
                
                if (normalize) {
                    #######
                    # dataMean = mean(dataEX_period_code[[var]],
                    # na.rm=TRUE)
                    dataMean = mean(dataEX_period_code$Value,
                                    na.rm=TRUE)
                    #######
                    trend = trendEX_period_code_var$a / dataMean
                } else {
                    trend = trendEX_period_code_var$a
                }
                
                if (!(trendEX_period_code_var$H | take_not_signif_into_account)) {
                    trend = NA
                }

                trendEX_period_code_var$trend = trend

                if (!is.null(period_change)) {
                    nPeriod_change = length(period_change)
                    if (nPeriod_change != 2) {
                        break
                    }
                    
                    for (jj in 1:nPeriod_change) {
                        Start = period_change[[jj]][1]
                        End = period_change[[jj]][2]
                        dataEX_period_code = dataEX[dataEX$Date >= Start &
                                                    dataEX$Date <= End &
                                                    dataEX$Code == code,]
                    
                        #######
                        # dataMean = mean(dataEX_period_code[[var]],
                        # na.rm=TRUE)
                        dataMean = mean(dataEX_period_code$Value,
                                        na.rm=TRUE)
                        #######

                        if (jj == 1) {
                            dataMean_tmp = dataMean                            
                        } else {
                            if (normalize) {
                                change = (dataMean - dataMean_tmp) / dataMean_tmp
                            } else {
                                change = dataMean - dataMean_tmp
                            }
                        }
                    }
                    trendEX_period_code_var$change = change
                    trendEX_period_code_var$period_change = list(period_change)
                }
                
                trendEX[sapply(lapply(trendEX$period,
                                      '==', period), all) &
                        trendEX$Code == code &
                        trendEX$var == var,] = trendEX_period_code_var
            }
        }
    }

    if (!is.null(period_change)) {
        trendEX = dplyr::mutate(dplyr::group_by(trendEX,
                                                var, period),
                                change_min=quantile(change,
                                                    exProb,
                                                    na.rm=TRUE),
                                change_max=quantile(change,
                                                    1-exProb,
                                                    na.rm=TRUE),
                                .keep="all")
    }    
    trendEX = dplyr::mutate(dplyr::group_by(trendEX,
                                            var, period),
                            trend_min=quantile(trend,
                                               exProb,
                                               na.rm=TRUE),
                            trend_max=quantile(trend,
                                               1-exProb,
                                               na.rm=TRUE),
                            .keep="all")
    
    trendEX = dplyr::ungroup(trendEX)
    return (trendEX)
}
