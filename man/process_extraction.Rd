% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/process_extraction.R
\name{process_extraction}
\alias{process_extraction}
\title{process_extraction}
\usage{
process_extraction(
  data,
  funct = max,
  funct_args = list(),
  timeStep = "year",
  samplePeriod = NULL,
  period = NULL,
  isDate = FALSE,
  NApct_lim = NULL,
  NAyear_lim = NULL,
  Seasons = c("DJF", "MAM", "JJA", "SON"),
  onlyDate4Season = FALSE,
  nameEX = "X",
  suffix = NULL,
  keep = NULL,
  compress = FALSE,
  expand = FALSE,
  rmNApct = FALSE,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{data}{Input data format is a tibble of at least a column of date, a column of numeric value, and a character column for names of time series in order to identify them. Thus, it is possible to have a tibble with multiple time series which can be grouped by their names.}

\item{funct}{The function (for example \code{mean}) that you want to use. Arguments of the chosen function can be passed to this extraction process, and the function can be previously defined.}

\item{funct_args}{A list of arguments needed for the function provided through \code{funct}.}

\item{timeStep}{A character specifying the time step for sampling the data. Possible values are "year", "none", "yearday", "month", "year-month", "season", and "year-season".}

\item{samplePeriod}{A vector of two dates to restrict the period of analysis. The imposed date format is "YYYY-mm-dd". As an example, it can be c("1950-01-01", "2020-12-31") to select data from the 1st January of 1950 to the end of December of 2020. The default option is \code{samplePeriod = NULL}, which considers all available data.}

\item{period}{A vector of two dates to further restrict the period of analysis within the \code{data} tibble. The imposed date format is "YYYY-mm-dd". This parameter allows selecting a specific subset of the data.}

\item{isDate}{Logical. If TRUE, the function will assume that Date is a date and not a numeric value.}

\item{NApct_lim}{Numeric. The maximum percentage of missing values in the time series allowed.}

\item{NAyear_lim}{Numeric. The maximum number of missing years allowed.}

\item{Seasons}{A vector of 4 characters representing the default season set. The default is c("DJF", "MAM", "JJA", "SON").}

\item{onlyDate4Season}{Logical. If TRUE, seasons computation will be based only on date.}

\item{nameEX}{A character specifying the name of the extracted variable.}

\item{suffix}{A character vector representing suffixes to be appended to the column names of the extracted variables. This parameter allows handling multiple extraction scenarios.}

\item{keep}{A character vector of column names to keep in the output dataframe.}

\item{compress}{Logical. Should the function return a tibble or a compressed tibble?}

\item{rmNApct}{Logical. Should rows with a high percentage of missing values be removed?}

\item{verbose}{Logical. Should intermediate messages be printed during the execution of the function?}

\item{...}{Additional arguments needed for the function provided through \code{funct}.}
}
\description{
This process extracts a variable from time series (for example the yearly mean of time series). Extraction can be yearly, monthly, or realized each month of every year and sampled differently along years or months.
}
\note{
documentation generated by chatGPT
}
\examples{
# Date
Start = as.Date("1972-01-01")
End = as.Date("2020-12-31")
Date = seq.Date(Start, End, by="day")

# Value to analyse
set.seed(100)
X = seq(1, length(Date))/1e4 + runif(length(Date), -100, 100)
X[as.Date("2000-03-01") <= Date & Date <= as.Date("2000-09-30")] = NA

# Creation of tibble
data = dplyr::tibble(Date=Date, ID="serie A", X=X)

# Extraction
dataEX = process_extraction(data=data,
                            samplePeriod=c("05-01",
                                           "11-30"),
                            funct=max,
                            na.rm=TRUE,
                            period=c(as.Date("1990-01-01"),
                                     as.Date("2020-12-31")),
                            timeStep="year")
dataEX
}
